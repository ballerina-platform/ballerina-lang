#
# Copyright (c) 2017, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
#
# WSO2 Inc. licenses this file to you under the Apache License,
# Version 2.0 (the "License"); you may not use this file except
# in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#

# -------------------------
# Compiler warning messages
# -------------------------

warning.syntax.warning=\
  {0}

warning.invalid.documentation.reference=\
  invalid reference in documentation ''{0}'' for type ''{1}''

warning.invalid.use.of.parameter.reference=\
  invalid usage of parameter reference outside of function definition ''{0}''

warning.undocumented.parameter=\
  undocumented parameter ''{0}''

warning.no.such.documentable.parameter=\
  no such documentable parameter ''{0}''

warning.parameter.already.documented =\
  parameter ''{0}'' already documented

warning.undocumented.field=\
  undocumented field ''{0}''

warning.no.such.documentable.field=\
  no such documentable field ''{0}''

warning.field.already.documented =\
  field ''{0}'' already documented

warning.undocumented.variable=\
  undocumented variable ''{0}''

warning.no.such.documentable.variable=\
  no such documentable variable ''{0}''

warning.variable.already.documented =\
  variable ''{0}'' already documented

warning.undocumented.return.parameter =\
  undocumented return parameter

warning.no.documentable.return.parameter =\
  no documentable return parameter

warning.no.such.documentable.attribute =\
  no such documentable attribute ''{0}'' with doc prefix ''{1}''

warning.duplicate.documented.attribute =\
  already documented attribute ''{0}''

warning.invalid.use.of.endpoint.documentation.attribute =\
  invalid use of doc prefix ''{0}''

warning.undefined.documentation.public.function=\
  undefined documentation for public function ''{0}''

warning.usage.of.deprecated.construct=\
  usage of construct ''{0}'' is deprecated

warning.invalid.deprecation.documentation=\
  invalid documentation: ''Deprecated'' documentation is only allowed on constructs annotated as ''@deprecated''

warning.deprecation.documentation.should.available=\
  constructs annotated as ''@deprecated'' must have ''Deprecated'' documentation

warning.deprecated.parameters.documentation.not.allowed=\
  ''Deprecated parameters'' documentation is not allowed here

warning.non.module.qualified.error.reason=\
  error reason ''{0}'' is not module qualified

warning.compiler.plugin.crashed=\
  compiler plugin crashed

warning.concurrent.calls.will.not.be.made.to.non.isolated.method.in.non.isolated.service=\
    concurrent calls will not be made to this method since the service and the method are not ''isolated''

warning.concurrent.calls.will.not.be.made.to.non.isolated.service=\
    concurrent calls will not be made to this method since the service is not an ''isolated'' service

warning.concurrent.calls.will.not.be.made.to.non.isolated.method=\
    concurrent calls will not be made to this method since the method is not an ''isolated'' method

warning.unused.local.variable=\
    unused variable ''{0}''

warning.checked.expr.invalid.usage.no.error.type.rhs=\
  invalid usage of the ''{0}'' expression operator: no expression type is equivalent to error type

# -------------------------
# Compiler error messages
# -------------------------

error.usage.of.worker.within.lock.is.prohibited=\
  cannot use a named worker inside a lock statement

error.usage.of.start.within.lock.is.prohibited=\
  cannot use an async call inside a lock statement

error.undefined.module=\
  undefined module ''{0}''

error.cyclic.module.imports.detected=\
  cyclic module imports detected ''{0}''

error.unused.module.prefix=\
  unused module prefix ''{0}''

error.redeclared.symbol=\
  redeclared symbol ''{0}''

error.redeclared.builtin.symbol=\
  redeclared builtin symbol ''{0}''

error.undefined.symbol=\
  undefined symbol ''{0}''

error.undefined.function=\
  undefined function ''{0}''

error.undefined.function.in.type=\
  undefined function ''{0}'' in type ''{1}''

error.undefined.method.in.object=\
  undefined method ''{0}'' in object ''{1}''

error.undefined.field.in.record=\
  undefined field ''{0}'' in record ''{1}''

error.undefined.connector=\
  undefined connector ''{0}''

error.undefined.field.in.structure.with.type=\
  undefined field ''{0}'' in {1} ''{2}''

error.undefined.field.in.structure=\
  undefined field ''{0}'' in ''{1}''

error.type.not.allowed.with.new=\
  type not allowed with new for type ''{0}''

error.invalid.intersection.type=\
  invalid intersection type ''{0}'': no intersection

error.invalid.non.readonly.intersection.type=\
  invalid intersection type ''{0}'', intersection types are currently supported only with ''readonly''

error.invalid.readonly.intersection.type=\
  invalid intersection type with ''readonly'', ''{0}'' can never be ''readonly''

error.invalid.readonly.object.intersection.type=\
  invalid intersection type: cannot have a ''readonly'' intersection with a ''readonly object''

error.intersection.not.allowed.with.type=\
  invalid intersection: field ''{1}'' contains a default value in type ''{0}''

error.invalid.readonly.object.type=\
  invalid ''readonly object'' ''{0}'': cannot have fields that are never ''readonly''

error.invalid.readonly.mapping.field=\
  invalid ''readonly'' mapping field ''{0}'': ''{1}'' can never be ''readonly''

error.stream.invalid.constraint=\
  invalid constraint type ''{0}'', expected a subtype of ''anydata|error''

error.stream.initialization.not.allowed.here=\
  'stream' initialization not allowed here

error.cannot.infer.object.type.from.lhs=\
  cannot infer type of the object from ''{0}''

error.object.uninitialized.field=\
  uninitialized field ''{0}''

error.uninitialized.variable=\
    uninitialized variable ''{0}''

error.cyclic.type.reference=\
  invalid cyclic type reference in ''{0}''

error.attempt.refer.non.accessible.symbol=\
  attempt to refer to non-accessible symbol ''{0}''

error.attempt.expose.non.public.symbol=\
  attempt to expose non-public symbol ''{0}''

error.invokable.must.return=\
  this {0} must return a result

error.main.should.be.public=\
  the ''main'' function should be public

error.invalid.main.params.type=\
   'main' function operand parameter ''{0}'' has invalid type ''{1}''

error.main.return.should.be.error.or.nil=\
   invalid ''main'' function return type ''{0}'', expected a subtype of ''error?'' containing ''()''

error.module.init.cannot.be.public=\
  the module ''init()'' function cannot be public

error.module.init.cannot.have.params=\
   the module ''init()'' function cannot accept parameters

error.module.init.return.should.be.error.or.nil=\
   invalid module ''init()'' function return type ''{0}'', expected a subtype of ''error?'' containing ''()''

error.atleast.one.worker.must.return=\
  at least one worker in the {0} must return a result

error.explicit.worker.cannot.be.default=\
  explicit workers cannot be named as ''default'' since the function already has an implicit worker named ''default''

error.fork.join.worker.cannot.return=\
  cannot return from a worker in fork/join

error.fork.join.invalid.worker.count=\
  fork/join minimum finishing worker count must be equal or less than the joining worker count

error.fork.join.syntax.empty.fork=\
  empty fork statement is not allowed

error.invalid.worker.flush.expression.for.worker=\
  invalid worker flush expression for ''{0}'', there are no worker send statements to ''{0}'' from ''{1}''

error.invalid.worker.flush.expression=\
   invalid worker flush expression, there are no worker send statements from ''{0}''

error.multi.value.return.expected=\
  multi value return is expected

error.single.value.return.expected=\
  single value return is expected

error.return.value.too.many=\
  too many return values

error.return.value.not.enough=\
  not enough return values

error.attached.functions.must.have.body=\
  object attached function definition must have a body ''{0}''

error.cannot.initialize.object=\
  cannot initialize object ''{0}'', no implementation for the interface ''{1}''

error.no.default.constructor.found=\
  no default constructor found for object ''{0}''

error.duplicated.error.catch=\
  error ''{0}'' already caught in catch block

error.unreachable.code=\
  unreachable code

warning.function.should.explicitly.return.a.value=\
  this function should explicitly return a value

error.continue.cannot.be.outside.loop=\
  continue cannot be used outside of a loop

error.break.cannot.be.outside.loop=\
  break cannot be used outside of a loop

error.rollback.cannot.be.outside.transaction.block=\
  rollback cannot be used outside of a transaction block

error.commit.cannot.be.outside.transaction.block=\
  commit cannot be used outside a transaction statement

error.retry.cannot.be.outside.transaction.block=\
  retry cannot be used outside of a transaction block

error.break.statement.cannot.be.used.to.exit.from.a.transaction=\
  break statement cannot be used to exit from a transaction without a commit or a rollback statement

error.continue.statement.cannot.be.used.to.exit.from.a.transaction=\
  continue statement cannot be used to exit from a transaction without a commit or a rollback statement

error.check.expression.invalid.usage.within.transaction.block=\
  ''check'' expression cannot be used within transaction block

error.return.statement.cannot.be.used.to.exit.from.a.transaction=\
  return statement cannot be used to exit from a transaction without a commit or a rollback statement

error.invalid.retry.count=\
  invalid transaction retry count

error.invalid.commit.count=\
  invalid transaction commit count

error.invalid.rollback.count=\
  invalid transaction rollback count

error.invalid.transaction.handler.args=\
  transaction handler function required single string parameter which is transaction id

error.invalid.transaction.handler.signature=\
  transaction handler function cannot have a return type

error.lambda.required.for.transaction.handler=\
  lambda function with string input parameter is required as transaction handler

error.done.statement.cannot.be.used.to.exit.from.a.transaction=\
  done statement cannot be used to exit from a transaction

error.transaction.cannot.be.used.within.handler=\
  transaction statement cannot be used within a transaction handler

error.transaction.cannot.be.used.within.transactional.scope=\
  transaction statement cannot be used within a transactional scope

error.nested.transactions.are.invalid=\
  transaction statement cannot be nested within another transaction block

error.invalid.function.pointer.assignment.for.handler=\
  invalid function pointer assignment for the transaction handler function

error.usage.of.start.within.transaction.is.prohibited=\
  usage of start within a transactional scope is prohibited

error.transactional.function.prohibited.outside.transactional.scope=\
  invoking transactional function outside transactional scope is prohibited

error.transactional.worker.prohibited.outside.transactional.scope=\
  use of transactional worker outside transactional scope is prohibited

error.rollback.cannot.be.within.transactional.function=\
  using rollback statement within a transactional function is prohibited

error.commit.cannot.be.within.transactional.function=\
  using commit statement within a transactional function is prohibited

error.max.one.commit.rollback.allowed.within.branch=\
  maximum of one commit and one rollback allowed within a branch

error.commit.not.allowed=\
  commit not allowed here

error.rollback.not.allowed=\
  rollback not allowed here

error.incompatible.types=\
  incompatible types: expected ''{0}'', found ''{1}''

error.incompatible.types.spread.op=\
  incompatible types: expected a map or a record, found ''{0}''

error.incompatible.types.field=\
  incompatible types: expected ''{0}'' for field ''{1}'', found ''{2}''

error.incompatible.sub.type.field=\
  included field ''{0}'' of type ''{1}'' cannot be overridden by a field of type ''{2}'': expected a subtype of ''{1}''

error.unknown.type=\
  unknown type ''{0}''

error.unary.op.incompatible.types=\
  operator ''{0}'' not defined for ''{1}''

error.binary.op.incompatible.types=\
  operator ''{0}'' not defined for ''{1}'' and ''{2}''

error.self.reference.var=\
  self referenced variable ''{0}''

error.worker.send.after.return=\
  invalid worker send statement position, can not be used after a non-error return

error.worker.receive.after.return=\
  invalid worker receive statement position, can not be used after a non-error return

error.unsupported.worker.send.position=\
  worker send statement position not supported yet, must be a top level statement in a worker

error.invalid.worker.receive.position=\
  invalid worker receive statement position, must be a top level statement in a worker

error.undefined.worker=\
  undefined worker ''{0}''

error.invalid.worker.join.result.type=\
  invalid worker join result type, expected 'map'

error.invalid.worker.timeout.result.type=\
  invalid worker timeout result type, expected 'map'

error.invalid.worker.reference=\
  unsupported worker reference ''{0}''

error.illegal.worker.reference.as.a.variable.reference=\
  multiple references to a named worker ''{0}'' as a variable reference is not allowed

error.invalid.worker.message.passing.after.wait.action=\
  invalid worker message passing after waiting for the same worker

error.worker.send.receive.parameter.count.mismatch=\
   parameter count mismatch in worker send/receive

error.worker.invalid.worker.interaction=\
   worker send/receive interactions are invalid; worker(s) cannot move onwards from the state: ''{0}''

error.worker.interactions.only.allowed.between.peers=\
  worker interactions are only allowed between peers

error.worker.multiple.fork.join.send=\
   only a single worker send can be executed for joining results in a fork/join

error.invalid.type.for.receive=\
   invalid type for worker receive ''{0}'', expected anydata

error.invalid.type.for.send=\
   invalid type for worker send ''{0}'', expected value:Cloneable

error.invalid.usage.of.receive.expression=\
   invalid usage of receive expression, var not allowed

error.invalid.wait.future.expr.mapping.constructors=\
  ''wait'' cannot be used with mapping constructors

error.invalid.wait.future.expr.actions=\
  ''wait'' cannot be used with actions

error.invalid.send.expr=\
  expected an expression, but found an action

error.assignment.count.mismatch=\
  assignment count mismatch: expected {0} values, but found {1}

error.assignment.required=\
  variable assignment is required

error.missing.key.expr.in.member.access.expr=\
  missing key expr in member access expr

error.already.initialized.symbol=\
  symbol ''{0}'' is already initialized

error.already.initialized.symbol.with.another=\
  symbol ''{0}'' is already initialized with ''{1}''

error.type.cast.not.yet.supported.for.type=\
  type cast not yet supported for type ''{0}''

error.let.expression.not.yet.supported.record.field=\
  let expressions are not yet supported for record fields

error.let.expression.not.yet.supported.object.field=\
  let expressions are not yet supported for object fields

error.incompatible.types.cast=\
  incompatible types: ''{0}'' cannot be cast to ''{1}''

error.invalid.function.invocation=\
  function invocation on type ''{0}'' is not supported

error.invalid.function.invocation.with.name=\
  invalid function ''{0}'' invocation on type ''{1}''

error.incompatible.types.cast.with.suggestion=\
  incompatible types: ''{0}'' cannot be cast to ''{1}'', use conversion expression

error.incompatible.types.conversion=\
  incompatible types: ''{0}'' cannot be converted to ''{1}''

error.incompatible.types.conversion.with.suggestion=\
  incompatible types: ''{0}'' cannot be convert to ''{1}'', use cast expression

error.unsafe.cast.attempt=\
  unsafe cast from ''{0}'' to ''{1}'', use multi-return cast expression

error.array.literal.not.allowed=\
  array literal not allowed here

error.string.template.literal.not.allowed=\
  string template literals not allowed here

error.invalid.literal.for.type=\
  invalid literal for type ''{0}''

error.invalid.literal.for.match.pattern=\
  invalid literal for match pattern; allowed literals are simple, tuple and record only

error.invalid.expr.with.type.guard.for.match=\
  invalid expression with type guard; only simple variable references are allowed

error.invalid.field.name.record.lit=\
  invalid field name ''{0}'' in type ''{1}''

error.rest.field.not.allowed=\
  rest field not allowed in closed records

error.open.record.constraint.not.allowed=\
  incompatible types: 'json' cannot be constrained with open record type ''{0}''

error.invalid.record.rest.descriptor=\
  invalid record rest descriptor

error.missing.required.record.field=\
  missing non-defaultable required record field ''{0}''

error.cannot.use.type.inclusion.with.more.than.one.open.record.with.different.rest.descriptor.types=\
  cannot use type inclusion with more than one open record with different rest descriptor types

error.default.values.not.allowed.for.optional.fields=\
  a default value specified for optional field ''{0}''

error.never.type.not.allowed.for.required.and.defaultable.params=\
  a required parameter or a defaultable parameter cannot be of type ''never'' or equivalent to type ''never''

error.invalid.client.remote.method.call=\
  cannot call a remote method with return type ''never'' or equivalent to type ''never''

error.never.typed.var.def.not.allowed=\
  cannot define a variable of type ''never'' or equivalent to type ''never''

error.never.typed.object.field.not.allowed=\
  cannot define an object field of type ''never'' or equivalent to type ''never''

error.too.many.args.call=\
  too many arguments in call to ''{0}()''

error.multi.value.in.single.value.context=\
  multi-valued ''{0}()'' in single-value context

error.multi.valued.expr.in.single.valued.context=\
  multi-valued expression in single-valued context

error.does.not.return.value=\
  ''{0}()'' does not return a value;

error.invalid.namespace.prefix=\
  invalid namespace prefix ''{0}''

error.mismatching.xml.start.end.tags=\
  mismatching start and end tags found in xml element

error.no.new.variables.var.assignment=\
  no new variables on left side

error.invalid.variable.assignment=\
  invalid assignment in variable ''{0}''

error.invalid.variable.assignment.declaration.final =\
  invalid assignment: ''{0}'' declaration is final

error.cannot.assign.value.to.final.field=\
  cannot assign a value to final ''{0}''

error.cannot.assign.value.to.potentially.initialized.final=\
  cannot assign a value to potentially initialized final ''{0}''

error.cannot.assign.value.to.function.argument=\
  cannot assign a value to function argument ''{0}''

error.cannot.assign.value.to.endpoint=\
  cannot assign a value to endpoint ''{0}''

error.cannot.update.readonly.value.of.type=\
  cannot update ''readonly'' value of type ''{0}''

error.cannot.update.readonly.record.field=\
  cannot update ''readonly'' record field ''{0}'' in ''{1}''

error.cannot.update.final.object.field=\
  cannot update ''final'' object field ''{0}''

error.operation.does.not.support.member.access=\
  invalid operation: type ''{0}'' does not support member access

error.operation.does.not.support.field.access=\
  invalid operation: type ''{0}'' does not support field access

error.operation.does.not.support.field.access.for.assignment=\
  invalid operation: type ''{0}'' does not support field access for assignment

error.operation.does.not.support.optional.field.access=\
  invalid operation: type ''{0}'' does not support optional field access

error.operation.does.not.support.field.access.for.non.required.field=\
  invalid operation: type ''{0}'' does not support field access for non-required field ''{1}''

error.operation.does.not.support.optional.field.access.for.field=\
  invalid operation: type ''{0}'' does not support optional field access for field ''{1}''

error.operation.does.not.support.member.access.for.assignment=\
  invalid operation: type ''{0}'' does not support member access for assignment

error.invalid.member.access.expr.struct.field.access=\
  invalid member access expression: expected string literal

error.invalid.member.access.expr.tuple.field.access=\
  invalid member access expression: expected integer literal

error.invalid.tuple.member.access.expr=\
  invalid tuple member access expression: value space ''{0}'' out of range

error.invalid.record.member.access.expr=\
  invalid record member access expression: value space ''{0}'' out of range

error.invalid.enum.expr=\
  invalid expression: expected enum type name ''{0}''

error.invalid.expr.in.match.stmt=\
  invalid expression in match statement

error.invalid.pattern.clauses.in.match.stmt=\
  invalid patterns in match statement. cannot combine typed and static patterns

error.static.value.match.only.supports.anydata=\
  static value match only supports anydata

error.func.defined.on.not.supported.type=\
  function ''{0}'' defined on not supported type ''{1}''

error.func.defined.on.non.local.type=\
  function ''{0}'' defined on non-local type ''{1}''

error.invalid.object.constructor=\
  invalid object constructor return type ''{0}'', expected a subtype of ''error?'' containing ''()''

error.explicit.invocation.of.record.init.is.not.allowed=\
  explicit invocation of ''{0}'' record initializer is not allowed

error.incompatible.type.constraint=\
  incompatible types: ''{0}'' cannot be constrained with ''{1}''

error.pkg.alias.not.allowed.here=\
  module alias not allowed here

error.undefined.annotation=\
  undefined annotation ''{0}''

error.unknown.annotation.attach.point=\
  unknown annotation attach point ''{0}}'

error.annotation.not.allowed=\
  annotation ''{0}'' is not allowed on {1}

error.annotation.attachment.cannot.have.a.value=\
  no annotation value expected for annotation ''{0}''

error.annotation.attachment.requires.a.value=\
  annotation value expected for annotation of record type ''{0}'' with required fields

error.annotation.attachment.cannot.specify.multiple.values=\
  cannot specify more than one annotation value for annotation ''{0}''

error.annotation.invalid.type=\
  annotation declaration requires a subtype of ''true'', ''map<value:Cloneable>'' or ''map<value:Cloneable>[]'', but \
  found ''{0}''

error.array.length.greater.that.2147483637.not.yet.supported=\
  array length greater that ''2147483637'' not yet supported

error.invalid.array.length=\
  invalid array length: array length should be a non-negative integer

error.cannot.resolve.const=\
  cannot resolve constant ''{0}''

#error.annotation.invalid.const.type=\
#  invalid type ''{0}'' for ''const'' annotation declaration, expected ''anydata''

error.annotation.requires.const=\
  annotation declaration with ''source'' attach point(s) should be a ''const'' declaration

error.incompatible.types.array.found=\
  incompatible types: expected a ''{0}'', found an array

error.xml.attribute.map.update.not.allowed=\
  xml attributes cannot be updated as a collection. update attributes one at a time

error.xml.qname.update.not.allowed=\
  cannot assign values to an xml qualified name

error.invalid.namespace.declaration=\
  cannot bind prefix ''{0}'' to the empty namespace name

error.cannot.update.xml.sequence=\
  cannot update an xml sequence

error.type.does.not.support.xml.navigation.access=\
  invalid operation: union type ''{0}'' does not support xml navigation access

error.xml.function.does.not.support.argument.type=\
  xml langlib functions does not support union types as their arguments


error.invalid.xml.ns.interpolation=\
  xml namespaces cannot be interpolated

error.cannot.find.xml.namespace.prefix=\
  cannot find xml namespace prefix ''{0}''

error.method.invocation.in.xml.navigation.expressions.not.supported=\
  method invocations are not yet supported within XML navigation expressions, use a grouping expression \
  (parenthesis) if you intend to invoke the method on the result of the navigation expression.

error.member.access.within.xml.navigation.expression.not.supported=\
  member access operations are not yet supported within XML navigation expressions, use a grouping expression \
  (parenthesis) if you intend to member-access the result of the navigation expression.

error.iterable.not.supported.collection=\
  incompatible types: ''{0}'' is not an iterable collection

error.iterable.not.supported.operation=\
  operation ''{0}'' does not support given collection type

error.cannot.iterate.a.closed.record.with.no.fields=\
  cannot iterate a closed record with no fields

error.iterable.too.many.variables=\
  too many variables are defined for iterable type ''{0}''

error.iterable.not.enough.variables=\
  not enough variables are defined for iterable type ''{0}'', require at least ''{1}'' variables

error.iterable.too.many.return.args=\
  too many return arguments are defined for operation ''{0}''

error.iterable.not.enough.return.args=\
  not enough return arguments are defined for operation ''{0}''

error.iterable.lambda.required=\
  single lambda function required here

error.iterable.lambda.tuple.required=\
  iterable lambda function required a single param or a tuple param

error.iterable.no.args.required=\
  no argument required for operation ''{0}''

error.iterable.lambda.incompatible.types=\
  incompatible lambda function types: expected ''{0}'', found ''{1}''

error.iterable.return.type.mismatch=\
  cannot assign return value of ''{0}'' operation here, use a reduce operation

error.invalid.token=\
  invalid token {0}

error.missing.token=\
  missing token {0} before {1}

error.extraneous.input=\
  extraneous input {0}

error.mismatched.input=\
  mismatched input {0}. expecting {1}

error.failed.predicate=\
  {0}

error.syntax.error=\
  {0}

error.invalid.shift.operator=\
  invalid shift operator

error.module.not.found=\
  cannot resolve module ''{0}''

error.invalid.module.declaration=\
  invalid module declaration: expected ''{0}'', found ''{1}''

error.missing.module.declaration=\
  missing module declaration: expected ''{0}''

error.unexpected.module.declaration=\
  invalid module declaration ''{0}'': no module declaration is needed for default module

error.object.type.required=\
  incompatible types: requires an object type, found ''{0}''

error.service.invalid.object.type=\
  given type ''{0}'' does not match with service type interface

error.service.decl.does.not.implement.required.constructs=\
  service declaration does not implement all required constructs of type: ''{0}''

error.service.function.invalid.invocation=\
  service method call is allowed only within the type descriptor

error.service.invalid.endpoint.type=\
  cannot infer type of the endpoint from the service type or binds of the service {0}

error.service.service.type.required.anonymous=\
  cannot infer type of the anonymous endpoint, requires a valid service type for service {0}

error.remote.function.in.non.network.object=\
  remote qualifier only allowed in client and service objects

error.unsupported.path.param.type=\
  only ''int'', ''string'', ''float'', ''boolean'', ''decimal'' types are supported as path params, found ''{0}''

error.unsupported.rest.path.param.type=\
  only ''int'', ''string'', ''float'', ''boolean'', ''decimal'' types are supported as rest path param, found ''{0}''

error.resource.function.in.non.service.object=\
  a resource function allowed in services only

error.resource.field.in.non.service.type=\
  resource fields are only allowed in service types

error.resource.function.invalid.return.type=\
  invalid resource function return type ''{0}'', expected a subtype of ''error?'' containing ''()''

error.remote.in.non.object.function=\
  remote modifier not allowed in non-object attached function {0}

error.unsupported.resource.function.declaration.in.object.type=\
  resource method declarations are not allowed in an object type definition

error.invalid.listener.var=\
  listener variable incompatible types: ''{0}'' is not a Listener object

error.invalid.listener.attachment=\
  invalid listener attachment

error.service.absolute.path.or.literal.required.by.listener=\
  service absolute path or literal is required by listener

error.service.path.literal.is.not.supported.by.listener=\
  service path literal is not supported by listener

error.service.absolute.path.is.not.supported.by.listener=\
  service absolute path is not supported by listener

error.service.path.literal.required.by.listener=\
  service path literal is required by the listener

error.service.absolute.path.required.by.listener=\
  service absolute path is required by the listener

error.service.type.is.not.supported.by.listener=\
  service type is not supported by the listener

error.invalid.action.invocation.syntax=\
  invalid remote method call ''.{0}()'': use ''->{0}()'' for remote method calls

error.invalid.method.invocation.syntax=\
  invalid method call ''->{0}()'': ''->'' can only be used with remote methods

error.invalid.init.invocation=\
  object ''init'' method call is allowed only within the type descriptor

error.invalid.resource.function.invocation=\
  resource function can not be invoked with in a service

error.invalid.function.pointer.invocation.with.type = \
  cannot call function pointer of type ''function''

error.invalid.action.invocation=\
  invalid remote method call: expected a client object, but found ''{0}''

error.tainted.value.passed.to.untainted.parameter=\
  tainted value passed to untainted parameter ''{0}''

error.tainted.value.passed.to.untainted.param.in.obj.method=\
  tainted value passed to untainted parameter ''{0}'' originating from object method ''{1}'' invocation

error.tainted.value.passed.to.global.variable=\
  tainted value passed to global variable ''{0}''

error.tainted.value.passed.to.module.object=\
  tainted value passed to module object ''{0}''

error.method.invocation.taint.global.object=\
  method invocation taint global object ''{0}''

error.tainted.value.passed.to.closure.variable=\
  tainted value passed to closure variable ''{0}''

error.unable.to.perform.taint.checking.with.recursion=\
  taint checking for ''{0}'' could not complete due to recursion with ''{1}'', add @tainted or @untainted to returns

error.unable.to.perform.taint.checking.for.builtin.method=taint analysis not defined for the builtin method: ''{0}''

error.tainted.return.not.annotated.tainted=\
  functions returning tainted value are required to annotate return signature @tainted: ''{0}''

error.tainted.param.not.annotated.tainted=\
  argument to parameter ''{0}'' is tainted by ''{1}'' hence require to annotate @tainted

error.entry.point.parameters.cannot.be.untainted=\
  entry point parameter ''{0}'' cannot be untainted

error.compiler.plugin.no.package.found=\
  cannot find module ''{0}'' specified in compiler plugin ''{1}''

error.compiler.plugin.no.annotations.found.in.package=\
  no annotations found in module ''{0}'' specified in compiler plugin ''{1}''

error.undefined.parameter=\
  undefined defaultable parameter ''{0}''

error.invalid.error.reason.type=\
  invalid error reason type ''{0}'', expected a subtype of ''string''

error.error.match.over.const.reason.ref.not.supported=\
  error match pattern with a constant reference as the reason is not yet supported

error.invalid.error.detail.type=\
  invalid error detail type ''{0}'', expected a subtype of ''{1}''

error.error.detail.arg.not.named.arg=\
  error detail argument must be passed as named arguments

error.missing.error.reason=\
  error reason is mandatory for direct error constructor

error.object.type.not.allowed=\
  object type not allowed as the constraint

error.duplicate.named.args=\
  redeclared argument ''{0}''

error.cannot.get.all.fields=\
  cannot get all fields from a {0}

error.operator.not.supported=\
  operator ''{0}'' cannot be applied to type ''{1}''

error.operator.not.allowed.variable=\
  operator ''{0}'' cannot be applied on variable ''{1}''

error.invalid.record.literal.key=\
  invalid key: only identifiers and strings are allowed as record literal keys

error.invalid.record.literal.identifier.key=\
  invalid key ''{0}'': identifiers cannot be used as rest field keys, expected a string literal or an expression

error.invalid.function.pointer.invocation=\
  invalid function pointer invocation on non-invokable field ''{0}'' in record ''{1}''

error.invalid.default.param.value=\
  invalid value for parameter ''{0}'': only simple literals allowed

error.illegal.init.method.in.object.type.descriptor=\
  object type descriptor ''{0}'' cannot have an init method

error.cannot.initialize.abstract.object=\
  cannot initialize abstract object ''{0}''

error.invalid.interface.of.non.abstract.object=\
  no implementation found for the function ''{0}'' of non-abstract object ''{1}''

error.unimplemented.referenced.method.in.class=\
  no implementation found for the method ''{0}'' of class ''{1}''

error.unimplemented.referenced.method.in.service.declaration=\
  no implementation found for the method ''{0}'' of service declaration ''{1}''

error.unimplemented.referenced.method.in.object.constructor=\
  no implementation found for the method ''{0}'' of object constructor ''{1}''

error.private.function.visibility=\
   function ''{0}'' can not have 'private' visibility

error.cannot.attach.functions.to.abstract.object=\
  cannot attach function ''{0}'' to abstract object ''{1}''

error.abstract.object.function.cannot.have.body=\
  function ''{0}'' in abstract object ''{1}'' cannot have a body

error.resource.function.cannot.be.extern=\
  external resource functions are not supported by the implementation

error.object.init.function.cannot.be.extern=\
  object ''init'' method cannot have an ''external'' implementation

error.private.object.constructor=\
  object initializer function can not be declared as private

error.private.field.abstract.object=\
  abstract object field: ''{0}'' can not be declared as private

error.field.with.default.value.abstract.object=\
  fields with default values are not yet supported with abstract objects

error.private.function.abstract.object=\
  interface function: ''{0}'' of abstract object ''{1}'' can not be declared as private

error.global.variable.cyclic.reference=\
  illegal cyclic reference ''{0}''

error.required.param.not.allowed.after.defaultable.param=\
  required parameter not allowed after defaultable parameters

error.defaultable.param.not.allowed.after.included.record.param=\
  defaultable parameter not allowed after included record parameters

error.required.param.not.allowed.after.included.record.param=\
  required parameter not allowed after included record parameters

error.expected.a.record.type.as.an.included.parameter = \
  expected a record type as an included parameter

error.positional.arg.defined.after.named.arg=\
  positional argument not allowed after named arguments

error.rest.arg.defined.after.named.arg=\
  rest argument not allowed after named arguments

error.missing.required.parameter=\
  missing required parameter ''{0}'' in call to ''{1}()''

error.extern.function.abstract.object=\
  external function: ''{0}'' not allowed in abstract object ''{1}''

error.incompatible.type.reference=\
  incompatible types: ''{0}'' is not an object

error.incompatible.type.reference.non.public.members=\
  incompatible type reference ''{0}'': a referenced object cannot have non-public fields or methods

error.incompatible.record.type.reference=\
  incompatible types: ''{0}'' is not a record

error.redeclared.type.reference=\
  redeclared type reference ''{0}''

error.redeclared.function.from.type.reference=\
  redeclared symbol ''{0}'': trying to copy a duplicate function through referenced type ''{1}''

error.referred.function.signature.mismatch=\
  mismatched function signatures: expected ''{0}'', found ''{1}''

error.configurable.variable.cannot.be.declared.with.var=\
  configurable variable cannot be declared with var

error.configurable.variable.must.be.anydata=\
  invalid type for configurable variable: expected a subtype of ''anydata''

error.only.simple.variables.are.allowed.to.be.configurable=\
  only simple variables are allowed to be configurable

error.configurable.variable.currently.not.supported=\
  configurable variable currently not supported for ''{0}''{1}

# match statement related error messages

error.match.stmt.cannot.guarantee.a.matching.pattern=\
  A matching pattern cannot be guaranteed for types ''{0}''

error.match.stmt.unreachable.pattern=\
  unreachable pattern: preceding patterns are too general or the pattern ordering is not correct

warning.match.stmt.unmatched.pattern=\
  pattern will not be matched

error.match.stmt.pattern.always.matches=\
  pattern will always be matched

warning.match.stmt.unreachable.pattern.available=\
  unreachable pattern

error.match.pattern.not.supported=\
  unsupported match pattern

error.match.patterns.should.contain.same.set.of.variables=\
  all match patterns should contain the same set of variables

error.match.pattern.cannot.repeat.same.variable=\
  same variable cannot repeat in a match pattern

error.rest.match.pattern.not.supported=\
  rest match pattern is not yet supported

error.match.pattern.variable.should.declared.as.constant=\
  variable ''{0}'' should be declared as constant

error.match.stmt.contains.two.default.patterns=\
  match statement has a 'static value' default pattern and a 'binding value' default pattern

error.can.not.find.match.error.reason.const=\
  cannot find error reason match constant: ''{0}''

# error type related errors

error.undefined.error.type.descriptor=\
  undefined error type descriptor ''{0}''

error.invalid.error.type.reference=\
  cannot create a new error value from ''{0}''

error.invalid.error.constructor.rest.detail.arg.on.detail.type.with.individual.fields=\
  error constructor does not accept additional detail args ''{0}'' when error detail type ''{1}'' contains individual \
  field descriptors

error.throw.stmt.not.supported=\
  throw statement not supported, use panic statement instead

error.try.stmt.not.supported=\
  try-catch statement not supported, use trap expression instead

error.unknown.builtin.method=\
  unknown builtin method ''{0}''

error.unsupported.builtin.method=\
  built-in method ''{0}'' not supported here

# checked expression related error messages

error.checked.expr.no.matching.error.return.in.encl.invokable=\
  invalid usage of the ''check'' expression operator: no matching error return type(s) in the enclosing invokable

error.fail.expr.no.matching.error.return.in.encl.invokable=\
  invalid usage of the ''fail'' expression operator: no matching error return type(s) in the enclosing invokable

error.on.fail.no.matching.error=\
  incompatible error definition type: ''{0}'' will not be matched to ''{1}''

error.start.require.invocation=\
  invalid async operation usage, require an invocation

error.invalid.expr.statement=\
  invalid statement

error.invalid.action.invocation.as.expr=\
  action invocation as an expression not allowed here

error.expression.of.never.type.not.allowed=\
  expression of type ''never'' or equivalent to type ''never'' not allowed here

error.this.function.should.panic=\
  function with return type ''never'' or equivalent to type ''never'' cannot implicitly return ''nil'' by falling off the end of the function body

error.ambiguous.type=\
  ambiguous type ''{0}''

error.usage.of.uninitialized.variable=\
  variable ''{0}'' is not initialized

error.uninitialized.object.fields=\
  field(s) ''{0}'' not initialized

error.uninitialized.variables=\
  variable(s) ''{0}'' not initialized

error.invalid.any.var.def=\
  invalid variable definition; can not infer the assignment type.

error.invalid.record.literal=\
  invalid usage of record literal with type ''{0}''

error.duplicate.key.in.record.literal=\
  invalid usage of {0} literal: duplicate key ''{1}''

error.duplicate.key.in.table.literal=\
  duplicate key found in table row key(''{0}'') : ''{1}''

error.duplicate.key.in.record.literal.spread.op=\
  invalid usage of {0} literal: duplicate key ''{1}'' via spread operator ''{2}''

error.possible.duplicate.of.field.specified.via.spread.op=\
  invalid usage of mapping constructor expression: key ''{0}'' may duplicate a key specified via spread field ''{1}''

error.spread.field.may.duplicate.already.specified.keys=\
  invalid usage of mapping constructor expression: spread field ''{0}'' may have already specified keys

error.multiple.inclusive.types=\
  invalid usage of mapping constructor expression: multiple spread fields of inclusive mapping types are not allowed

error.invalid.array.literal=\
  invalid usage of array literal with type ''{0}''

error.invalid.tuple.literal=\
  invalid usage of tuple literal with type ''{0}''

error.invalid.type.object.constructor=\
  invalid usage of ''object constructor expression'' with type ''{0}''

error.invalid.list.constructor.type=\
  invalid usage of list constructor: type ''{0}'' does not have a filler value

error.invalid.array.element.type=\
  array element type ''{0}'' does not have an implicit initial value, use ''{1}''

error.invalid.type.new.literal=\
  invalid usage of ''new'' with type ''{0}''

error.mismatching.array.literal.values=\
  size mismatch in closed array. expected ''{0}'', but found ''{1}''

error.index.out.of.range=\
  index out of range: index: ''{0}''

error.invalid.array.size.reference=\
  invalid reference expression ''{0}'' as array size: expected a constant reference expression

error.list.index.out.of.range=\
  list index out of range: index: ''{0}''

error.array.index.out.of.range=\
  array index out of range: index: ''{0}'', size: ''{1}''

error.closed.array.type.can.not.infer.size=\
  invalid usage of closed type: can not infer array size

error.invalid.key.func.return.type=\
  invalid sort key function return type: ''{0}'' is not an ordered type

error.invalid.sort.array.member.type=\
  invalid member type of the array/tuple to sort: ''{0}'' is not an ordered type

error.closed.array.type.not.initialized=\
  invalid usage of closed type: array not initialized

error.invalid.list.member.access.expr=\
  invalid list member access expression: value space ''{0}'' out of range

error.invalid.array.member.access.expr=\
  invalid array member access expression: value space ''{0}'' out of range

error.invalid.usage.of.keyword=\
  illegal usage of keyword ''{0}''

# Variable Reference Errors

error.invalid.list.binding.pattern=\
  invalid list binding pattern; member variable count mismatch with member type count

error.invalid.type.for.tuple.var.expr=\
  invalid tuple variable; expecting a tuple type but found ''{0}'' in expression

error.invalid.list.binding.pattern.decl=\
  invalid list binding pattern: expected an array or a tuple, but found ''{0}''

error.invalid.list.binding.pattern.inference=\
  invalid list binding pattern: attempted to infer a list type, but found ''{0}''

error.invalid.record.binding.pattern=\
  invalid record binding pattern with type ''{0}''

error.invalid.field.in.record.binding.pattern=\
  invalid record binding pattern; unknown field ''{0}'' in record type ''{1}''

error.invalid.record.literal.in.binding.pattern=\
  record literal is not supported for record binding pattern

error.no.matching.record.ref.found=\
  no matching record reference found for field ''{0}''

error.multiple.matching.record.ref.found=\
  multiple matching record references found for field ''{0}''

error.cannot.match.closed.record.variable.ref=\
  can not match record variable reference, type ''{0}'' is not a closed record type

error.cannot.match.closed.record.variable.ref.fields=\
  not enough fields to match to closed record type ''{0}''

error.invalid.type.definition.for.record.var=\
  invalid record variable; expecting a record type but found ''{0}'' in type definition

error.invalid.type.definition.for.error.var=\
  invalid error variable; expecting an error type but found ''{0}'' in type definition

error.invalid.error.binding.pattern=\
  invalid error binding pattern with type ''{0}''

error.invalid.error.reason.binding.pattern=\
  invalid error reason binding pattern, error reason should be ''var {0}''

error.invalid.error.rest.binding.pattern=\
  invalid error rest binding pattern, error rest param should be ''var {0}''

error.invalid.error.match.pattern=\
  invalid error match pattern, cannot match error

error.duplicate.variable.in.binding.pattern=\
  variables in a binding pattern must be distinct; found duplicate variable ''{0}''

error.invalid.variable.reference.in.binding.pattern=\
  invalid binding pattern, variable reference ''{0}'' cannot be used with binding pattern

error.invalid.type.for.rest.descriptor=\
  invalid rest descriptor type; expecting an array type but found ''{0}''

error.cannot.assign.value.to.type.def=\
  cannot assign a value to a type definition

# safe navigation operator related errors

error.safe.navigation.not.required=\
  safe navigation operator not required for type ''{0}''

error.optional.field.access.not.required.on.lhs=\
  optional field access cannot be used in the target expression of an assignment

error.tuple.index.out.of.range=\
  tuple index out of range: index: ''{0}'', size: ''{1}''

error.incompatible.type.check=\
  incompatible types: ''{0}'' will not be matched to ''{1}''

# streaming related errors

error.invalid.stream.constructor=\
  ''{0}'' is not a valid constructor for streams type

error.invalid.stream.constructor.iterator = \
  invalid stream constructor. expected a subtype of ''object '{' public isolated function next() returns {0}; '}''', \
  but found ''{1}''

error.invalid.stream.constructor.closeable.iterator = \
  invalid stream constructor. expected a subtype of ''object '{' public isolated function next() returns {0}; public \
  isolated function close() returns error?; '}''', but found ''{1}''

error.invalid.stream.constructor.expected.type=\
  invalid expected stream type. ''{0}'' does not return an error

error.invalid.next.method.return.type=\
  invalid next method return type. expected: ''{0}''

error.invalid.stream.usage.with.from = \
  type 'stream' not allowed here; to use from on a type 'stream', it should be the first from clause in the query.

error.order.by.not.supported=\
  order by not supported for complex type fields, order key should belong to a basic type

error.error.type.expected = \
  type ''{0}'' not allowed here; expected an ''error'' or a subtype of ''error''.

error.invalid.table.constraint.subtype = \
  invalid constraint type. expected subtype of ''map<any|error>'' but found ''{0}''

error.table.key.specifier.mismatch = \
  table key specifier mismatch. expected: ''{0}'' but found ''{1}''

error.key.specifier.size.mismatch.with.key.constraint = \
  table key specifier mismatch with key constraint. expected: ''{0}'' fields but found ''{1}''

error.key.specifier.empty.with.key.constraint = \
  table key specifier mismatch with key constraint. expected: ''{0}'' fields but key specifier is empty

error.key.specifier.mismatch.with.key.constraint = \
  table key specifier ''{0}'' does not match with key constraint type ''{1}''

error.invalid.key.constraint.provided.for.access = \
  invalid key constraint provided for member access. key constraint expected with type ''{0}''

error.cannot.update.table.using.member.access.lvexpr = \
  cannot update ''{0}'' with member access expression

error.multi.key.member.access.not.supported = \
  invalid member access with ''{0}'': member access with multi-key expression is only allowed with subtypes of ''table''

error.member.access.not.supported.keyless.table = \
  member access is not supported for keyless table ''{0}''

error.invalid.field.name.in.key.specifier = \
  field name ''{0}'' used in key specifier is not found in table constraint type ''{1}''

error.key.specifier.field.must.be.readonly = \
  field ''{0}'' used in key specifier must be a readonly field

error.key.specifier.field.must.be.required = \
  field ''{0}'' used in key specifier must be a required field

error.key.specifier.field.must.be.anydata = \
  invalid type ''{0}'' for field ''{1}'' used in key specifier, expected sub type of anydata

error.key.specifier.field.value.must.be.constant.expr = \
  value expression of key specifier ''{0}'' must be a constant expression

error.key.constraint.not.supported.for.table.with.map.constraint = \
  table with constraint of type 'map' cannot have key specifier or key type constraint

error.cannot.infer.member.type.for.table.due.ambiguity = \
  cannot infer the member type from table constructor. field ''{0}'' type is ambiguous

error.cannot.infer.member.type.for.table = \
  cannot infer the member type from table constructor; no values are provided in table constructor

error.on.conflict.only.works.with.tables.with.key.specifier = \
  on conflict can only be used with queries which produce tables with key specifiers

error.arrow.expression.mismatched.parameter.length=\
  invalid number of parameters used in arrow expression. expected: ''{0}'' but found ''{1}''

error.arrow.expression.cannot.infer.type.from.lhs=\
  cannot infer types of the arrow expression with unknown invokable type

error.arrow.expression.not.supported.iterable.operation=\
  arrow expression can not be used with ''{0}'' iterable

# decimal related errors

error.integer.too.large=\
  Integer ''{0}'' too large

error.integer.too.small=\
  Integer ''{0}'' too small

error.hexadecimal.too.large=\
  Hexadecimal ''{0}'' too large

error.hexadecimal.too.small=\
  Hexadecimal ''{0}'' too small

error.clone.invocation.invalid=\
  Cannot clone a value of a type other than anydata \
  (boolean|int|byte|float|decimal|string|xml|table|anydata[]|map<anydata>|records (with only `anydata` fields)|()), \
  but found ''{0}''

# data flow analysis errors

error.partially.initialized.variable=\
  variable ''{0}'' may not have been initialized

# stamp inbuilt method related error
error.incompatible.stamp.type=\
  incompatible stamp type: type ''{0}'' cannot be stamped as type ''{1}''

error.not.supported.source.for.stamp=\
  stamp function on type ''{0}'' is not supported

error.redeclared.import.module=\
  redeclared import module ''{0}''

error.cannot.infer.type=\
  cannot infer type here

error.cannot.infer.error.type=\
  cannot infer type of the error from ''{0}''

error.invalid.error.detail.rec.does.not.match=\
  invalid error constructor, error details does not match

error.invalid.error.reason.argument.to.indirect.error.constructor=\
  indirect error constructor only accept error details as named arguments

error.invalid.indirect.error.constructor.invocation=\
  cannot infer reason from error constructor: ''{0}''

error.invalid.functional.constructor.invocation=\
  use of ''start'' not allowed with functional constructor ''{0}'()''

error.missing.error.detail.arg=\
  missing error detail arg for error detail field ''{0}''

error.invalid.error.detail.arg.type=\
  invalid arg type in error detail field ''{0}'', expected ''{1}'', found ''{2}''

error.unknown.error.detail.arg.to.closed.detail=\
  unknown error detail arg ''{0}'' passed to closed error detail type ''{1}''

error.invalid.error.detail.rest.arg=\
  invalid error detail rest arg ''{0}'' passed to open detail record ''{1}''

error.type.required.for.const.with.expressions=\
  type is required for constants with expressions

error.cannot.update.constant.value=\
  cannot update constant value

error.cannot.assign.value.to.constant=\
  cannot assign a value to a constant

error.invalid.const.declaration=\
  cannot declare a constant with type ''{0}'', expected a subtype of ''anydata'' that is not ''never''

error.expression.is.not.a.constant.expression=\
  expression is not a constant expression

error.invalid.const.expression=\
  invalid constant expression, reason ''{0}''

error.const.expression.not.supported=\
  const expressions are not yet supported here

error.constant.declaration.not.yet.supported.for.type=\
  constant declaration not yet supported for type ''{0}''

error.self.reference.constant=\
  self referenced constant ''{0}''

error.invalid.use.of.experimental.feature=\
  using experimental feature ''{0}''. use ''--experimental'' flag to enable the experimental features

error.type.param.outside.lang.module=\
  typeParam annotation is not supported here

error.builtin.subtype.outside.lang.module=\
  builtinSubtype annotation is not supported here

error.isolated.param.outside.lang.module=\
  ''isolatedParam'' annotation is not allowed here

error.isolated.param.used.with.invalid.type=\
  ''isolatedParam'' annotation is only allowed on a parameter of a function type

error.isolated.param.used.in.a.non.isolated.function=\
  ''isolatedParam'' annotation is only allowed on a parameter of an ''isolated'' function

error.invalid.lvalue.lhs.of.assignment=\
  invocations are not supported on the left hand side of an assignment

error.invalid.package.name.qualifier=\
  invalid package name ''{0}''

error.invalid.char.colon.in.field.access.expr=\
  invalid character '':'' in field access expression

error.identifier.literal.only.supports.alphanumerics=\
  identifier literal only supports alphanumeric characters

error.incompatible.mapping.constructor.expression=\
  incompatible mapping constructor expression for type ''{0}''

error.mapping.constructor.compatible.type.not.found =\
  a type compatible with mapping constructor expressions not found in type ''{0}''

error.cannot.infer.types.for.tuple.binding=\
  invalid list constructor expression: types cannot be inferred for ''{0}''

error.invalid.unicode=\
  invalid unicode ''{0}''

error.method.too.large=\
  method is too large: ''{0}''

error.file.too.large=\
  file is too large: ''{0}''

error.class.not.found=\
  '{ballerina/jballerina.java}'CLASS_NOT_FOUND ''{0}''

error.no.class.def.found=\
  '{ballerina/jballerina.java}'NO_CLASS_DEF_FOUND ''{0}''

error.method.not.found=\
  '{ballerina/jballerina.java}'METHOD_NOT_FOUND ''{0}''

error.constructor.not.found=\
  '{ballerina/jballerina.java}'CONSTRUCTOR_NOT_FOUND ''{0}''

error.error.constructor.compatible.type.not.found =\
    compatible type for error constructor expression not found in type ''{0}''

error.field.not.found=\
  '{ballerina/jballerina.java}'FIELD_NOT_FOUND ''{0}''

error.invalid.number.of.parameters=\
  '{ballerina/jballerina.java}'INVALID NUMBER OF PARAMETERS ''{0}''

error.invalid.parameter.type=\
  '{ballerina/jballerina.java}'INVALID PARAMETER TYPE ''{0}''

error.overloaded.method=\
  '{ballerina/jballerina.java}'OVERLOADED_METHODS ''{0}''

error.unsupported.primitive.type.reason=\
  '{ballerina/jballerina.java}'UNSUPPORTED_PRIMITIVE_TYPE ''{0}''

error.method.signature.not.match=\
  '{ballerina/jballerina.java}'METHOD_SIGNATURE_DOES_NOT_MATCH ''{0}''

error.invalid.attribute.reference=\
  invalid attribute reference

error.illegal.function.change.list.size=\
  cannot call ''{0}'' on fixed length list(s) of type ''{1}''

error.illegal.function.change.tuple.shape=\
  cannot call ''{0}'' on tuple(s) of type ''{1}'': cannot violate inherent type

error.invalid.non.external.dependently.typed.function=\
  a function with a non-''external'' function body cannot be a dependently-typed function

error.invalid.param.type.for.return.type=\
  invalid parameter reference: expected ''typedesc'', found ''{0}''

error.invalid.typedesc.param=\
  default value for a ''typedesc'' parameter used in the return type should be a reference to a type

error.incompatible.type.for.inferred.typedesc.value=\
  incompatible type for parameter ''{0}'' with inferred typedesc value: expected ''{1}'', found ''{2}''

error.multiple.infer.typedesc.params=\
  cannot have more than one defaultable parameter with an inferred typedesc default

error.invalid.dependently.typed.return.type.with.inferred.typedesc.param=\
  invalid return type: members of a dependently-typed union type with an inferred typedesc parameter should have \
  disjoint basic types

error.cannot.infer.type.for.param=\
  cannot infer type for parameter ''{0}''

error.cannot.use.inferred.typedesc.default.with.unreferenced.param=\
  cannot use an inferred typedesc default with a parameter on which the return type does not depend on

error.invalid.raw.template.type=\
  invalid literal for type ''{1}'': raw templates can only be assigned to abstract subtypes of ''{0}''

error.multiple.compatible.raw.template.types=\
  ambiguous type for raw template: found multiple types compatible with ''{0}'' in ''{1}''

error.invalid.num.of.strings=\
  invalid raw template: expected {0} string(s), but found {1} string(s)

error.invalid.num.of.insertions=\
  invalid raw template: expected {0} insertion(s), but found {1} insertion(s)

error.invalid.raw.template.assignment=\
  invalid raw template assignment: ''{0}'' should be an abstract object

error.invalid.number.of.fields=\
  invalid raw template assignment: ''{0}'' should only have the ''strings'' and ''insertions'' fields

error.methods.not.allowed=\
  invalid raw template assignment: ''{0}'' should be a type without methods

error.distinct.typing.only.support.objects.and.errors=\
  distinct typing is only supported for object type and error type

error.variable.decl.with.var.without.initializer=\
  initializer required for variables declared with var

error.object.constructor.init.function.cannot.have.parameters=\
  object constructor ''init'' method cannot have parameters

error.object.constructor.does.not.support.type.reference.members=\
  object constructor does not support type reference members

error.invalid.mutable.access.in.isolated.function=\
  invalid access of mutable storage in an ''isolated'' function

error.invalid.mutable.access.as.record.default=\
  invalid access of mutable storage in the default value of a record field

error.invalid.mutable.access.as.object.default=\
  invalid access of mutable storage in the initializer of an object field

error.invalid.non.isolated.function.as.argument=\
  incompatible types: expected an ''isolated'' function

error.invalid.non.isolated.invocation.in.isolated.function=\
  invalid invocation of a non-isolated function in an ''isolated'' function

error.invalid.non.isolated.invocation.as.record.default=\
  invalid invocation of a non-isolated function in the default value of a record field

error.invalid.non.isolated.invocation.as.object.default=\
  invalid invocation of a non-isolated function in the initializer of an object field

error.invalid.non.isolated.init.expression.in.isolated.function=\
  invalid non-isolated initialization expression in an ''isolated'' function

error.invalid.non.isolated.init.expression.as.record.default=\
  invalid non-isolated initialization expression in the default value of a record field

error.invalid.non.isolated.init.expression.as.object.default=\
  invalid non-isolated initialization expression in the initializer of an object field

error.invalid.async.invocation.in.isolated.function=\
  async invocation not allowed in an ''isolated'' function

error.invalid.worker.declaration.in.isolated.function=\
  worker declaration not allowed in an ''isolated'' function

error.invalid.fork.statement.in.isolated.function=\
  fork statement not allowed in an ''isolated'' function

error.invalid.non.private.mutable.field.in.isolated.object=\
  invalid non-private mutable field in an ''isolated'' object

error.invalid.mutable.field.access.in.isolated.object.outside.lock=\
  invalid access of a mutable field of an ''isolated'' object outside a ''lock'' statement

error.invalid.non.isolated.expression.as.initial.value=\
  invalid initial value expression: expected an isolated expression

error.invalid.transfer.out.of.lock.with.restricted.var.usage=\
  invalid attempt to transfer out a value from a ''lock'' statement with restricted variable usage: expected an \
  isolated expression

error.invalid.transfer.into.lock.with.restricted.var.usage=\
  invalid attempt to transfer a value into a ''lock'' statement with restricted variable usage

error.invalid.non.isolated.invocation.in.lock.with.restricted.var.usage=\
  invalid invocation of a non-isolated function in a ''lock'' statement with restricted variable usage

error.invalid.isolated.variable.access.outside.lock=\
  invalid access of an ''isolated'' variable outside a ''lock'' statement

error.invalid.assignment.in.lock.with.restricted.var.usage=\
  cannot assign to a variable outside the ''lock'' statement with restricted variable usage, if not just a variable name

error.invalid.usage.of.multiple.restricted.vars.in.lock=\
  cannot access more than one variable for which usage is restricted in a single ''lock'' statement

error.invalid.isolated.qualifier.on.module.no.init.var.decl=\
  an uninitialized module variable declaration cannot be marked as ''isolated''

error.only.a.simple.variable.can.be.marked.as.isolated=\
  only a simple variable can be marked as ''isolated''

error.invalid.read.only.class.inclusion.in.object.type.descriptor=\
  object type inclusion cannot be used with a ''readonly class'' in an object type descriptor

error.invalid.inclusion.with.mismatched.qualifiers=\
  invalid object type inclusion: missing ''{0}'' qualifier(s) in the referencing object

error.invalid.reference.with.mismatched.qualifiers=\
  invalid type reference: missing ''{0}'' qualifier(s) in the referencing object constructor expression

error.invalid.read.only.typedesc.inclusion.in.object.typedesc=\
  object type inclusion cannot be used with a ''readonly'' type descriptor in an ''object'' type descriptor

error.invalid.read.only.typedesc.inclusion.in.non.read.only.class=\
  object type inclusion cannot be used with a ''readonly'' type descriptor in a ''class'' that is not ''readonly''

error.invalid.read.only.class.inclusion.in.non.read.only.class=\
  object type inclusion cannot be used with a ''readonly class'' in a ''class'' that is not ''readonly''

error.invalid.field.in.object.constructor.expr.with.readonly.reference=\
  invalid field in an object constructor expression with a ''readonly'' reference: ''{0}'' can never be ''readonly''

error.mismatched.visibility.qualifiers.in.object.field=\
  mismatched visibility qualifiers for field ''{0}'' with object type inclusion

error.invalid.inclusion.of.object.with.private.members=\
  invalid object type inclusion with an object that has private fields or methods

error.multiple.receive.action.not.yet.supported=multiple receive action not yet supported

error.async.send.action.not.yet.supported.as.expression=\
  async send action not yet supported as expression

error.invalid.readonly.field.type=\
  invalid ''readonly'' field, ''{0}'' can never be ''readonly''

error.continue.not.allowed=\
  continue not allowed here

error.break.not.allowed=\
  break not allowed here

error.unused.variable.with.inferred.type.including.error=\
  unused variable ''{0}'' with inferred type including error

error.invalid.iterable.type=\
  invalid iterable type ''{0}'': an iterable object must be a subtype of ''{1}''

error.invalid.iterable.completion.type.in.foreach.next.function=\
  invalid completion type ''{0}'' in foreach statement: next method completion type cannot contain type ''{1}''

error.invalid.method.call.expr.on.field=\
  invalid method call expression: expected a function type, but found ''{0}''

error.incompatible.type.wait.future.expr=\
  incompatible types: expected ''{0}'', found eventual type ''{1}'' for wait future expression ''{2}''

error.same.array.type.as.main.param=\
   'main' function can have at most one array parameter

error.variable.and.array.type.as.main.param=\
   'main' function cannot have operand parameter ''{0}'' of type ''{1}'' and array of type ''{2}'' together

error.invalid.main.option.params.type=\
   'main' function option parameter ''{0}'' via included record ''{1}'' has invalid type ''{2}''

error.optional.operand.precedes.operand=\
   'main' function optional operand parameter ''{0}'' of type ''{1}'' cannot precede operand parameter ''{2}'' \
  of type ''{3}''

error.unsupported.remote.method.name.in.scope=\
  unsupported remote method name, ''{0}'' already exists as a method or field name in the object type

error.unsupported.type.intersection=\
  unsupported intersection ''{0}''

error.wild.card.binding.pattern.only.supports.type.any=\
  a wildcard binding pattern can be used only with a value that belong to type ''any''

error.underscore.not.allowed.as.identifier=\
  ''_'' is a keyword, and may not be used as an identifier

error.configurable.variable.module.ambiguity=\
  configurable variable name ''{0}'' creates an ambiguity with module ''{1}''

error.invalid.usage.of.check.in.record.field.default.expression=\
  cannot use ''check'' in the default expression of a record field

error.invalid.usage.of.check.in.object.field.initializer.in.object.with.no.init.method=\
  cannot use ''check'' in an object field initializer of an object with no ''init'' method

error.invalid.usage.of.check.in.object.field.initializer.with.init.method.return.type.mismatch=\
  usage of ''check'' in field initializer is allowed only when compatible with the return type of the ''init'' \
   method: expected ''{0}'', found ''{1}''

error.field.access.cannot.be.used.to.access.optional.fields=\
  field access cannot be used to access an optional field of a type that includes nil, use optional field access or member access

error.undeclared.field.in.record=\
  undeclared field ''{0}'' in record ''{1}''

error.invalid.field.access.in.record.type=\
  invalid field access: ''{0}'' is not a required field in record ''{1}'', use member access to access a field that \
  may have been specified as a rest field

error.undeclared.and.nilable.fields.in.union.of.records=\
  field access can only be used to access required fields or optional fields of non-nilable types, field ''{0}'' \
  is undeclared in record(s) ''{1}'' and type includes nil in record(s) ''{2}''

error.undeclared.field.in.union.of.records=\
  field access can only be used to access required fields or optional fields of non-nilable types, field ''{0}'' \
  is undeclared in record(s) ''{1}''

error.nilable.field.in.union.of.records=\
  field access can only be used to access required fields or optional fields of non-nilable types, type of \
  field ''{0}'' includes nil in record(s) ''{1}''

error.invalid.assignment.to.narrowed.var.in.loop=\
  invalid attempt to assign a value to a variable narrowed outside the loop

error.invalid.non.isolated.call.in.match.guard=\
  cannot call a non-isolated function/method in a match guard when the type of the action/expression being matched \
  is not a subtype of ''readonly''

error.invalid.call.with.mutable.args.in.match.guard=\
  cannot call a function/method in a match guard with an argument of a type that is not a subtype of ''readonly''

# hints
hint.unnecessary.condition=\
  unnecessary condition: expression will always evaluate to ''true''

hint.unnecessary.condition.for.variable.of.type.never=\
  unnecessary condition: expression will always evaluate to ''true'' for variable of type ''never''

hint.expression.always.false=\
  expression will always evaluate to ''false''

error.float.too.large=\
  float ''{0}'' too large

error.float.too.small=\
  float ''{0}'' too small

error.constant.cyclic.reference=\
  illegal cyclic reference ''{0}''
