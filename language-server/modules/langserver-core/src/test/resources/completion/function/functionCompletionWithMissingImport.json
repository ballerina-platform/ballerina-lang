{
  "position": {
    "line": 1,
    "character": 7
  },
  "source": "function/source/functionCompletionWithMissingImport.bal",
  "items": [
    {
      "label": "openReadableFile(string path)((io:ReadableByteChannel|io:GenericError|io:ConnectionTimedOutError))",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/io_  \n  \nRetrieves a ReadableByteChannel from a given file path.\n  \n  \n---    \n**Parameters**  \n- _path_  \n    Relative/absolute path string to locate the file  \n  \n  \n**Return**  \n(ballerina/io:ReadableByteChannel|ballerina/io:GenericError|ballerina/io:ConnectionTimedOutError)"
        }
      },
      "insertText": "openReadableFile(${1})",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 0,
              "character": 0
            },
            "end": {
              "line": 0,
              "character": 0
            }
          },
          "newText": "import ballerina/io;\n"
        }
      ],
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "openWritableFile(string path, boolean append)((io:WritableByteChannel|io:GenericError|io:ConnectionTimedOutError))",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/io_  \n  \nRetrieves a WritableByteChannel from a given file path.\n  \n  \n---    \n**Parameters**  \n- _path_  \n    Relative/absolute path string to locate the file  \n  \n- _append_  \n    Append to end of file.  \n(Default Parameter)  \n  \n**Return**  \n(ballerina/io:WritableByteChannel|ballerina/io:GenericError|ballerina/io:ConnectionTimedOutError)"
        }
      },
      "insertText": "openWritableFile(${1})",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 0,
              "character": 0
            },
            "end": {
              "line": 0,
              "character": 0
            }
          },
          "newText": "import ballerina/io;\n"
        }
      ],
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "createReadableChannel(byte[] content)((io:ReadableByteChannel|io:GenericError|io:ConnectionTimedOutError))",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/io_  \n  \nCreates an in-memory channel which will reference stream of bytes.\n  \n  \n---    \n**Parameters**  \n- _content_  \n    Content which should be exposed as channel  \n  \n  \n**Return**  \n(ballerina/io:ReadableByteChannel|ballerina/io:GenericError|ballerina/io:ConnectionTimedOutError)"
        }
      },
      "insertText": "createReadableChannel(${1})",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 0,
              "character": 0
            },
            "end": {
              "line": 0,
              "character": 0
            }
          },
          "newText": "import ballerina/io;\n"
        }
      ],
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "openReadableCsvFile(string path, (,|\t|:) fieldSeparator, string charset, int skipHeaders)((io:ReadableCSVChannel|io:GenericError|io:ConnectionTimedOutError))",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/io_  \n  \nRetrieves a readable CSV channel from a give file path.\n  \n  \n---    \n**Parameters**  \n- _path_  \n    File path which describes the location of the CSV  \n  \n- _fieldSeparator_  \n    CSV record separator (i.e comma or tab)  \n(Default Parameter)  \n- _charset_  \n    Encoding characters in the file represents  \n(Default Parameter)  \n- _skipHeaders_  \n    Number of headers which should be skipped  \n(Default Parameter)  \n  \n**Return**  \n(ballerina/io:ReadableCSVChannel|ballerina/io:GenericError|ballerina/io:ConnectionTimedOutError)"
        }
      },
      "insertText": "openReadableCsvFile(${1})",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 0,
              "character": 0
            },
            "end": {
              "line": 0,
              "character": 0
            }
          },
          "newText": "import ballerina/io;\n"
        }
      ],
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "openWritableCsvFile(string path, (,|\t|:) fieldSeparator, string charset, int skipHeaders)((io:WritableCSVChannel|io:GenericError|io:ConnectionTimedOutError))",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/io_  \n  \nRetrieves a writable CSV channel from a give file path.\n  \n  \n---    \n**Parameters**  \n- _path_  \n    File path which describes the location of the CSV  \n  \n- _fieldSeparator_  \n    CSV record separator (i.e comma or tab)  \n(Default Parameter)  \n- _charset_  \n    Encoding characters in the file represents  \n(Default Parameter)  \n- _skipHeaders_  \n    Number of headers which should be skipped  \n(Default Parameter)  \n  \n**Return**  \n(ballerina/io:WritableCSVChannel|ballerina/io:GenericError|ballerina/io:ConnectionTimedOutError)"
        }
      },
      "insertText": "openWritableCsvFile(${1})",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 0,
              "character": 0
            },
            "end": {
              "line": 0,
              "character": 0
            }
          },
          "newText": "import ballerina/io;\n"
        }
      ],
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "print(...(any|error))",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/io_  \n  \nPrints `any` or `error` value(s) to the STDOUT.  \n  \n---    \n**Parameters**  \n- _values_  \n    The value(s) to be printed.  \n"
        }
      },
      "insertText": "print(${1});",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 0,
              "character": 0
            },
            "end": {
              "line": 0,
              "character": 0
            }
          },
          "newText": "import ballerina/io;\n"
        }
      ],
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "println(...(any|error))",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/io_  \n  \nPrints `any` or `error` value(s) to the STDOUT followed by a new line.  \n  \n---    \n**Parameters**  \n- _values_  \n    The value(s) to be printed.  \n"
        }
      },
      "insertText": "println(${1});",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 0,
              "character": 0
            },
            "end": {
              "line": 0,
              "character": 0
            }
          },
          "newText": "import ballerina/io;\n"
        }
      ],
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "sprintf(string format, ...(any|error))(string)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/io_  \n  \nReturns a formatted string using the specified format string and arguments. Following format specifiers are allowed.\n   b              boolean\n   B              boolean (ALL_CAPS)\n   d              int\n   f              float\n   x              hex\n   X              HEX (ALL_CAPS)\n   s              string (This specifier is applicable for any of the supported types in Ballerina.\n                  These values will be converted to their string representation.)\n  \n  \n---    \n**Parameters**  \n- _format_  \n    A format string  \n  \n- _args_  \n    Arguments referenced by the format specifiers in the format string.  \n  \n  \n**Return**  \nstring"
        }
      },
      "insertText": "sprintf(${1})",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 0,
              "character": 0
            },
            "end": {
              "line": 0,
              "character": 0
            }
          },
          "newText": "import ballerina/io;\n"
        }
      ],
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "readln(any a)(string)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/io_  \n  \nReturns the input read from STDIN.\n  \n  \n---    \n**Parameters**  \n- _a_  \n    Any value to be printed  \n  \n  \n**Return**  \nstring"
        }
      },
      "insertText": "readln(${1})",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 0,
              "character": 0
            },
            "end": {
              "line": 0,
              "character": 0
            }
          },
          "newText": "import ballerina/io;\n"
        }
      ],
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "ReadableByteChannel",
      "kind": "Class",
      "detail": "Object",
      "documentation": {
        "left": "ReadableByteChannel represents an input resource (i.e file, socket). which could be used to source bytes."
      },
      "insertText": "ReadableByteChannel",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 0,
              "character": 0
            },
            "end": {
              "line": 0,
              "character": 0
            }
          },
          "newText": "import ballerina/io;\n"
        }
      ]
    },
    {
      "label": "ReadableCharacterChannel",
      "kind": "Class",
      "detail": "Object",
      "documentation": {
        "left": "Represents a channel which could be used to read characters through a given ReadableByteChannel."
      },
      "insertText": "ReadableCharacterChannel",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 0,
              "character": 0
            },
            "end": {
              "line": 0,
              "character": 0
            }
          },
          "newText": "import ballerina/io;\n"
        }
      ]
    },
    {
      "label": "ReadableCSVChannel",
      "kind": "Class",
      "detail": "Object",
      "documentation": {
        "left": "Represents a ReadableCSVChannel which could be used to read records from CSV file."
      },
      "insertText": "ReadableCSVChannel",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 0,
              "character": 0
            },
            "end": {
              "line": 0,
              "character": 0
            }
          },
          "newText": "import ballerina/io;\n"
        }
      ]
    },
    {
      "label": "ReadableDataChannel",
      "kind": "Class",
      "detail": "Object",
      "documentation": {
        "left": "Represents a data channel for reading data."
      },
      "insertText": "ReadableDataChannel",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 0,
              "character": 0
            },
            "end": {
              "line": 0,
              "character": 0
            }
          },
          "newText": "import ballerina/io;\n"
        }
      ]
    },
    {
      "label": "ReadableTextRecordChannel",
      "kind": "Class",
      "detail": "Object",
      "documentation": {
        "left": "Represents a channel which will allow to read"
      },
      "insertText": "ReadableTextRecordChannel",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 0,
              "character": 0
            },
            "end": {
              "line": 0,
              "character": 0
            }
          },
          "newText": "import ballerina/io;\n"
        }
      ]
    },
    {
      "label": "StringReader",
      "kind": "Class",
      "detail": "Object",
      "documentation": {
        "left": "Represents a reader which will wrap string content as a channel."
      },
      "insertText": "StringReader",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 0,
              "character": 0
            },
            "end": {
              "line": 0,
              "character": 0
            }
          },
          "newText": "import ballerina/io;\n"
        }
      ]
    },
    {
      "label": "WritableByteChannel",
      "kind": "Class",
      "detail": "Object",
      "documentation": {
        "left": "WritableByteChannel represents an output resource (i.e file, socket). which could be used to sink bytes."
      },
      "insertText": "WritableByteChannel",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 0,
              "character": 0
            },
            "end": {
              "line": 0,
              "character": 0
            }
          },
          "newText": "import ballerina/io;\n"
        }
      ]
    },
    {
      "label": "WritableCharacterChannel",
      "kind": "Class",
      "detail": "Object",
      "documentation": {
        "left": "Represents a channel which could be used to write characters through a given WritableCharacterChannel."
      },
      "insertText": "WritableCharacterChannel",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 0,
              "character": 0
            },
            "end": {
              "line": 0,
              "character": 0
            }
          },
          "newText": "import ballerina/io;\n"
        }
      ]
    },
    {
      "label": "WritableCSVChannel",
      "kind": "Class",
      "detail": "Object",
      "documentation": {
        "left": "Represents a WritableCSVChannel which could be used to write records from CSV file."
      },
      "insertText": "WritableCSVChannel",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 0,
              "character": 0
            },
            "end": {
              "line": 0,
              "character": 0
            }
          },
          "newText": "import ballerina/io;\n"
        }
      ]
    },
    {
      "label": "WritableDataChannel",
      "kind": "Class",
      "detail": "Object",
      "documentation": {
        "left": "Represents a WritableDataChannel for writing data."
      },
      "insertText": "WritableDataChannel",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 0,
              "character": 0
            },
            "end": {
              "line": 0,
              "character": 0
            }
          },
          "newText": "import ballerina/io;\n"
        }
      ]
    },
    {
      "label": "WritableTextRecordChannel",
      "kind": "Class",
      "detail": "Object",
      "documentation": {
        "left": "Represents a channel which will allow to write records through a given WritableCharacterChannel."
      },
      "insertText": "WritableTextRecordChannel",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 0,
              "character": 0
            },
            "end": {
              "line": 0,
              "character": 0
            }
          },
          "newText": "import ballerina/io;\n"
        }
      ]
    },
    {
      "label": "Format",
      "kind": "Enum",
      "detail": "Union",
      "documentation": {
        "left": "Format which will be used to represent the CSV.\n\nDEFAULT - Would default to the format specified by CSVChannel. Precedence will be given to field\n          separator and record separator.\n\nCSV - Field separator would be \",\" and the record separator would be new line.\n\nTDF - Field separator will be tab and record separator will be new line."
      },
      "insertText": "Format",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 0,
              "character": 0
            },
            "end": {
              "line": 0,
              "character": 0
            }
          },
          "newText": "import ballerina/io;\n"
        }
      ]
    },
    {
      "label": "Separator",
      "kind": "Enum",
      "detail": "Union",
      "documentation": {
        "left": "Field separators which are supported by DelimitedTextRecordChannel."
      },
      "insertText": "Separator",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 0,
              "character": 0
            },
            "end": {
              "line": 0,
              "character": 0
            }
          },
          "newText": "import ballerina/io;\n"
        }
      ]
    },
    {
      "label": "Error",
      "kind": "Enum",
      "detail": "Union",
      "insertText": "Error",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 0,
              "character": 0
            },
            "end": {
              "line": 0,
              "character": 0
            }
          },
          "newText": "import ballerina/io;\n"
        }
      ]
    },
    {
      "label": "Mode",
      "kind": "Enum",
      "detail": "Union",
      "insertText": "Mode",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 0,
              "character": 0
            },
            "end": {
              "line": 0,
              "character": 0
            }
          },
          "newText": "import ballerina/io;\n"
        }
      ]
    },
    {
      "label": "ByteOrder",
      "kind": "Enum",
      "detail": "Finite",
      "documentation": {
        "left": "Represents network byte order.\n\nBIG_ENDIAN - specifies the bytes to be in the order of most significant byte first\n\nLITTLE_ENDIAN - specifies the byte order to be the least significant byte first"
      },
      "insertText": "ByteOrder",
      "insertTextFormat": "Snippet",
      "additionalTextEdits": [
        {
          "range": {
            "start": {
              "line": 0,
              "character": 0
            },
            "end": {
              "line": 0,
              "character": 0
            }
          },
          "newText": "import ballerina/io;\n"
        }
      ]
    }
  ]
}
