{
  "position": {
    "line": 2,
    "character": 11
  },
  "source": "function/source/iterableOperation3.bal",
  "items": [
    {
      "label": "getTextValue()(string)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.xml_  \n  \nGet the text value of a XML. If the XML is a sequence, concatenation of the text values of the members of the\nsequence is returned. If the XML is an element, then the text value of the sequence of children is returned. If\nthe XML is a text item, then the text is returned. Otherwise, an empty string is returned.\n  \n  \n  \n**Returns** `string`   \n- Text value of the xml  \n  \n"
        }
      },
      "sortText": "130",
      "insertText": "getTextValue()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "setName(string xName)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.xml_  \n  \nChange the name of element `elmem` to `xName`.\n  \n**Params**  \n- `string` xName: new name"
        }
      },
      "sortText": "130",
      "insertText": "setName(${1});",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "isComment()(boolean)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.xml_  \n  \nReturns true if `x` is a singleton xml sequence consisting of a comment item.\n  \n  \n  \n**Returns** `boolean`   \n- true if `x` is a xml comment item  \n  \n"
        }
      },
      "sortText": "130",
      "insertText": "isComment()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "select(string qname)(xml)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.xml_  \n  \nGet all the items that are of element type, and matches the given qualified name, in an XML sequence.\n  \n**Params**  \n- `string` qname: Qualified name of the element  \n  \n**Returns** `xml`   \n- All the elements-type items in the given XML sequence, that matches the qualified name  \n  \n"
        }
      },
      "sortText": "130",
      "insertText": "select(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "getName()(string)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.xml_  \n  \nReturns a string giving the expanded name of `elem`.\n  \n  \n  \n**Returns** `string`   \n- element name  \n  \n"
        }
      },
      "sortText": "130",
      "insertText": "getName()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "removeChildren(string qname)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.xml_  \n  \nRemove children matching the given name from an XML. This operation has no effect\nif the XML is not an element type XML.\n  \n**Params**  \n- `string` qname: Namespace qualified name of the children to be removed"
        }
      },
      "sortText": "130",
      "insertText": "removeChildren(${1});",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "getContent()(string)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.xml_  \n  \nReturns the content of a text or processing instruction or comment item.\n  \n  \n  \n**Returns** `string`   \n- content of `x`  \n  \n"
        }
      },
      "sortText": "130",
      "insertText": "getContent()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "setAttributes(map<any> attributes)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.xml_  \n  \nSets the attributes to the provided attributes map.\n  \n**Params**  \n- `map<any>` attributes: Attributes map"
        }
      },
      "sortText": "130",
      "insertText": "setAttributes(${1});",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "getElementName()(string)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.xml_  \n  \nGet the fully qualified name of the element as a string. Returns an empty string if the XML is not a singleton.\n  \n  \n  \n**Returns** `string`   \n- Qualified name of the XML as a string  \n  \n"
        }
      },
      "sortText": "130",
      "insertText": "getElementName()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "iterator()()",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.xml_  \n  \nReturns an iterator over the xml items of `x`\n  \n  \n  \n**Returns** ``   \n- iterator object  \n  \n"
        }
      },
      "sortText": "130",
      "insertText": "iterator()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "getTarget()(string)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.xml_  \n  \nReturns the target part of the processing instruction.\n  \n  \n  \n**Returns** `string`   \n- target potion of `x`  \n  \n"
        }
      },
      "sortText": "130",
      "insertText": "getTarget()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "strip()(xml)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.xml_  \n  \nStrips any text items from an XML sequence that are all whitespace.\n  \n  \n  \n**Returns** `xml`   \n- Striped sequence  \n  \n"
        }
      },
      "sortText": "130",
      "insertText": "strip()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "isReadOnly()(boolean)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.value_  \n  \nTests whether `v` is read-only, i.e. immutable\nReturns true if read-only, false otherwise.\n  \n  \n  \n**Returns** `boolean`   \n- true if read-only, false otherwise  \n  \n"
        }
      },
      "sortText": "130",
      "insertText": "isReadOnly()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "slice(int startIndex, int endIndex)(xml)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.xml_  \n  \nSlice and return a subsequence of the an XML sequence.\n  \n**Params**  \n- `int` startIndex: Start index, inclusive  \n- `int` endIndex: End index, exclusive  \n  \n**Returns** `xml`   \n- Sliced sequence  \n  \n"
        }
      },
      "sortText": "130",
      "insertText": "slice(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "copy()(xml)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.xml_  \n  \nMake a deep copy of an XML.\n  \n  \n  \n**Returns** `xml`   \n- A Copy of the XML  \n  \n"
        }
      },
      "sortText": "130",
      "insertText": "copy()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "removeAttribute(string qname)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.xml_  \n  \nRemove an attribute from an XML.\n  \n**Params**  \n- `string` qname: Qualified name of the attribute"
        }
      },
      "sortText": "130",
      "insertText": "removeAttribute(${1});",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "map(function ((xml|string)) returns ((xml|string)) func)(xml)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.xml_  \n  \nFor xml sequence returns the result of applying function `func` to each member of sequence `item`.\nFor xml element returns the result of applying function `funct` to `item`.\n  \n**Params**  \n- `function ((xml|string)) returns ((xml|string))` func: a function to apply to each child or `item`  \n  \n**Returns** `xml`   \n- new xml value containing result of applying function `func` to each child or `item`  \n  \n"
        }
      },
      "sortText": "130",
      "insertText": "map(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "XMLIterator",
      "kind": "Class",
      "detail": "Object",
      "sortText": "120",
      "insertText": "XMLIterator",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "isText()(boolean)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.xml_  \n  \nReturns true if `x` is an xml sequence consisting of one or more character items.\n  \n  \n  \n**Returns** `boolean`   \n- true if `x` is a sequence containing any charactor items  \n  \n"
        }
      },
      "sortText": "130",
      "insertText": "isText()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "selectDescendants(string qname)(xml)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.xml_  \n  \nSearches in children recursively for elements matching the qualified name and returns a sequence containing them\nall. Does not search within a matched result.\n  \n**Params**  \n- `string` qname: Qualified name of the element  \n  \n**Returns** `xml`   \n- All the descendants that matches the given qualified name, as a sequence  \n  \n"
        }
      },
      "sortText": "130",
      "insertText": "selectDescendants(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "isProcessingInstruction()(boolean)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.xml_  \n  \nReturns true if `x` is a singleton xml sequence consisting of a processing instruction item.\n  \n  \n  \n**Returns** `boolean`   \n- true if `x` is a xml processing instruction  \n  \n"
        }
      },
      "sortText": "130",
      "insertText": "isProcessingInstruction()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "getAttributes()(map<string>)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.xml_  \n  \nReturns the map representing the attributes of `elem`.\nThis includes namespace attributes.\nThe keys in the map are the expanded name of the attribute.\nPanics if `isElement(elem)` is not true.\nThere is no setAttributes function.\n  \n  \n  \n**Returns** `map<string>`   \n- attributes of `x`  \n  \n"
        }
      },
      "sortText": "130",
      "insertText": "getAttributes()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "appendChildren(xml children)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.xml_  \n  \nAppend children to an XML if its an element type XML. Error otherwise.\nNew children will be appended at the end of the existing children.\n  \n**Params**  \n- `xml` children: children"
        }
      },
      "sortText": "130",
      "insertText": "appendChildren(${1});",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "isElement()(boolean)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.xml_  \n  \nReturns true if `x` is a singleton xml sequence consisting of an element item.\n  \n  \n  \n**Returns** `boolean`   \n- true if `x` is an xml element item  \n  \n"
        }
      },
      "sortText": "130",
      "insertText": "isElement()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "forEach(function ((xml|string)) returns () func)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.xml_  \n  \nFor xml sequence apply the `func` to children of `item`.\nFor xml element apply the `func` to `item`.\n  \n**Params**  \n- `function ((xml|string)) returns ()` func: a function to apply to each child or `item`"
        }
      },
      "sortText": "130",
      "insertText": "forEach(${1});",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "cloneReadOnly()(anydata)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.value_  \n  \nReturns a clone of `value` that is read-only, i.e. immutable.\nIt corresponds to the ImmutableClone(v) abstract operation,\ndefined in the Ballerina Language Specification.\n  \n"
        }
      },
      "sortText": "130",
      "insertText": "cloneReadOnly()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "length()(int)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.xml_  \n  \nReturns number of XML items in `x`.\n  \n  \n  \n**Returns** `int`   \n- number of XML items in `x`  \n  \n"
        }
      },
      "sortText": "130",
      "insertText": "length()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "isEmpty()(boolean)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.xml_  \n  \nCheck whether the XML sequence is empty.\n  \n  \n  \n**Returns** `boolean`   \n- Boolean flag indicating whether the XML sequence is empty  \n  \n"
        }
      },
      "sortText": "130",
      "insertText": "isEmpty()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "isSingleton()(boolean)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.xml_  \n  \nCheck whether the XML sequence contains only a single element.\n  \n  \n  \n**Returns** `boolean`   \n- Boolean flag indicating whether the XML sequence contains only a single element  \n  \n"
        }
      },
      "sortText": "130",
      "insertText": "isSingleton()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "getItemType()((element|sequence|text|comment|pi))",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.xml_  \n  \nGet the type of a XML as a string. If the XML is singleton, type can be one of 'element', 'text', 'comment' or 'pi'.\nReturns an empty string if the XML is not a singleton.\n  \n  \n  \n**Returns** `(element|sequence|text|comment|pi)`   \n- Type of the XML as a string  \n  \n"
        }
      },
      "sortText": "130",
      "insertText": "getItemType()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "concat(...(xml|string))(xml)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.xml_  \n  \nConcatenate all the `xs`. Empty xml sequence if empty.\n  \n  \n  \n**Returns** `xml`   \n- xml sequence containing `xs`  \n  \n"
        }
      },
      "sortText": "130",
      "insertText": "concat(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "filter(function ((xml|string)) returns (boolean) func)(xml)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.xml_  \n  \nFor xml sequence returns a new xml sequence constructed from children of `x` for which `func` returns true.\nFor xml element returns a new xml sequence constructed from `x` if `x` applied to `funct` returns true, else\nreturns an empty sequence.\n  \n**Params**  \n- `function ((xml|string)) returns (boolean)` func: a predicate to apply to each child to determine if it should be included  \n  \n**Returns** `xml`   \n- new xml sequence containing filtered children  \n  \n"
        }
      },
      "sortText": "130",
      "insertText": "filter(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "getChildren()(xml)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.xml_  \n  \nReturns the children of `elem`.\nPanics if `isElement(elem)` is not true.\n  \n  \n  \n**Returns** `xml`   \n- children of `elem`  \n  \n"
        }
      },
      "sortText": "130",
      "insertText": "getChildren()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "elements()(xml)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.xml_  \n  \nGet all the items that are of element type in an XML sequence.\n  \n  \n  \n**Returns** `xml`   \n- All the elements-type items in the given XML sequence  \n  \n"
        }
      },
      "sortText": "130",
      "insertText": "elements()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "clone()(anydata)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.value_  \n  \nReturns a clone of `value`.\nA clone is a deep copy that does not copy immutable subtrees.\nA clone can therefore safely be used concurrently with the original.\nIt corresponds to the Clone(v) abstract operation,\ndefined in the Ballerina Language Specification.\n  \n"
        }
      },
      "sortText": "130",
      "insertText": "clone()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "toString()(string)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.value_  \n  \nReturns a simple, human-readable representation of `value` as a string.\n  \n  \n  \n**Returns** `string`   \n- simple, human-readable string representation of `value`  \n  \n- if `value` is a string, then returns `value`  \n- if `value` is `()`, then returns an empty string  \n- if `value` is boolean, then the string `true` or `false`  \n- if `value` is an int, then return `value` represented as a decimal string  \n- if `value` is a float or decimal, then return `value` represented as a decimal string,  \nwith a decimal point only if necessary, but without any suffix indicating the type of `value`  \nreturn `NaN`, `Infinity` for positive infinity, and `-Infinity` for negative infinity  \n- if `value` is a list, then returns the results toString on each member of the list  \nseparated by a space character  \n- if `value` is a map, then returns key=value for each member separated by a space character  \n- if `value` is xml, then returns `value` in XML format (as if it occurred within an XML element)  \n- if `value` is table, TBD  \n- if `value` is an error, then a string consisting of the following in order  \n1. the string `error`  \n2. a space character  \n3. the reason string  \n4. if the detail record is non-empty  \n1. a space character  \n2. the result of calling toString on the detail record  \n- if `value` is an object, then  \n- if `value` provides a `toString` method with a string return type and no required methods,  \nthen the result of calling that method on `value`  \n- otherwise, `object` followed by some implementation-dependent string  \n- if `value` is any other behavioral type, then the identifier for the behavioral type  \n(`function`, `future`, `service`, `typedesc` or `handle`)  \nfollowed by some implementation-dependent string  \n  \nNote that `toString` may produce the same string for two Ballerina values  \nthat are not equal (in the sense of the `==` operator).  \n  \n"
        }
      },
      "sortText": "130",
      "insertText": "toString()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "setChildren((xml|string) children)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.xml_  \n  \nSets the children of `elem` to `children`.\nPanics if `isElement(elem)` is not true.\n  \n**Params**  \n- `(xml|string)` children: xml or string to set as children"
        }
      },
      "sortText": "130",
      "insertText": "setChildren(${1});",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    }
  ]
}
