#
# Copyright (c) 2017, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
#
# WSO2 Inc. licenses this file to you under the Apache License,
# Version 2.0 (the "License"); you may not use this file except
# in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#

#the following will interpreted as: invalid type 'typName'
invalid.type = invalid type ''{0}''
incompatible.types = incompatible types: expected ''{0}'', found ''{1}''
incompatible.arguments = arguments of incompatible types: argument list ''{0}'' cannot be passed to function expecting parameter list ''{1}''
redeclared.symbol = redeclared symbol ''{0}''
incompatible.types.cannot.convert = incompatible types: ''{0}'' cannot be converted to ''{1}''
cannot.convert.with.suggestion = incompatible types: ''{0}'' cannot be converted to ''{1}'', try casting
incompatible.types.cannot.cast = incompatible types: ''{0}'' cannot be cast to ''{1}''
incompatible.jtypes.cannot.cast = incompatible types: ''{0}'' cannot be cast to ''{1}''
cannot.cast.with.suggestion = incompatible types: ''{0}'' cannot be cast to ''{1}'', try conversion
unreachable.statement = unreachable statement
incompatible.types.boolean.expected = incompatible types: expected ''boolean'', found ''{0}''
no.statements.while.loop = no statements in the while loop in
unknown.operator.in.unary = unknown operator ''{0}'' in unary expression
ref.type.init.not.allowed.here = reference type initializer is not allowed here
struct.map.init.not.allowed = struct/map initializer is not allowed here
connector.init.not.allowed = connector initializer is not allowed here
array.init.not.allowed.here = array initializer is not allowed here
invalid.field.name.struct.init = invalid field name in struct initializer
unknown.field.in.struct = unknown field ''{0}'' in struct ''{1}''
invalid.type.in.map.index.expected.string = invalid type ''{0}'' in map index: expected ''string''
undefined.symbol = undefined symbol ''{0}''
non.integer.array.index = non-integer array index type ''{0}''
non.string.map.index = non-string map index type ''{0}''
invalid.operation.not.support.member.access = invalid operation: type ''{0}'' does not support member access
multiple.value.in.single.value.context = multiple-value ''{0}()'' in single-value context
reply.statement.cannot.used.in.function = reply statement cannot be used in a function definition
reply.statement.cannot.used.in.action = reply statement cannot be used in a action definition
action.invocation.not.allowed.in.reply = action invocation is not allowed in a reply statement
not.enough.arguments.to.return = not enough arguments to return
too.many.arguments.to.return = too many arguments to return
cannot.use.type.in.return.statement = incompatible types in return statement. expected ''{0}'', found ''{1}''
cannot.use.create.for.value.types = cannot use ''create'' for value types
incompatible.types.expected.xml = incompatible types: expected xml
cannot.assign.value.constant = cannot assign a value to constant ''{0}''
assignment.count.mismatch = assignment count mismatch: {0} != {1}
cannot.assign.in.multiple.assignment = cannot assign {0} to ''{1}'' (type {2}) in multiple assignment
var.is.repeated.on.left.side.assignment = ''{0}'' is repeated on the left side of assignment
undefined.function  = undefined function ''{0}''
undefined.connector = undefined connector ''{0}''
undefined.action = undefined action ''{0}'' in connector ''{1}''
undefined.native.action = undefined native action ''{0}'' in connector ''{1}''
invalid.operation.operator.not.defined = invalid operation: operator {0} not defined on ''{1}''
struct.not.found = struct ''{0}'' not found
must.be.struct.type = {0} must be of struct type
invalid.operation.incompatible.types = invalid operation: incompatible types ''{0}'' and ''{1}''
unused.import.module = unused import module ''{0}''
redeclared.import.module = redeclared import module name ''{0}''
unsupported.operator = unsupported operator ''{0}''
action.invocation.not.allowed.here = action invocation is not allowed here
undefined.module.name = undefined module name ''{0}'' in ''{1}''
template.expression.not.allowed.here = xml/json template expression is not allowed here
connector.init.not.allowed.here = connector initializer is not allowed here
only.count.1.allowed.this.version = only count 1 is allowed in this version
only.error.type.here = only a struct type structurally equivalent to 'ballerina.lang.errors:Error' is allowed here
break.stmt.not.allowed.here = break statement is not allowed here
undefined.type.mapper = undefine type mapper ''{0}''
incompatible.types.unknown.found = incompatible types: expected a ''{0}''
built.in.type.names.not.allowed.as.identifier = {0} is a built in type name which is not allowed as identifier
incompatible.types.connector.expected = incompatible types: expected a connector name, found ''{0}''
ambiguous.functions  = function reference ''{0}'' is ambiguous, functions ''{1}'' and ''{2}'' matches
casting.any.to.wrong.value.type = cannot cast ''any'' with type ''{0}'' to type ''{1}''
casting.any.without.init = cannot cast ''null'' value to type ''{0}''
unsupported.annotation.attribute.value = unsupported attribute value. only basic literals are allowed
undefined.annotation = undefined annotation ''{0}''
annotation.not.allowed = annotation ''{0}'' is not allowed in {1}
no.such.attribute = no such attribute ''{0}'' in annotation ''{1}''
invalid.default.value = only value types are allowed for default values
invalid.attribute.type = invalid attribute type ''{0}''. only value types and annotations allowed
incompatible.types.array.found = incompatible types: expected a ''{0}'', found an array
worker.interaction.not.valid = worker interaction is not valid
incompatible.assignment = incompatible types: ''{0}'' cannot be assigned to ''{1}''
index.number.too.large = index number too large: {0}
array.index.out.of.range = array index out of range: index: {0}, size: {1}
casting.without.required.field = cannot cast ''{0}'' to type ''{1}'': no such field ''{2}''
missing.field.in.json = no such field found in json
casting.failed.with.cause = cannot cast ''{0}'' to type ''{1}'': {2}
cannot.set.value.incompatible.types = cannot set value to ''{0}'': expected a ''{1}'', but found ''{2}''
cannot.get.value.incompatible.types = cannot get value from ''{0}'': expected a ''{1}'', but found ''{2}''
incompatible.field.type.for.casting = error while mapping ''{0}'': incompatible types: expected ''{1}'', found ''{2}''
incompatible.types.in.json = incompatible types: expected ''{0}'', found ''{1}'' in json
indexing.not.supported.map.element = invalid operation: indexing is not supported for map elements of type ''{0}''. cast the value before access with index
json.set.error = failed to set element to json: {0}
json.get.error = failed to get element from json: {0}
dynamic.keys.not.supported.for.struct = only static keys are supported for accessing struct fields
struct.field.child.has.module.identifier = struct child fields cannot have module identifiers: ''{0}''
duplicated.error.catch = error ''{0}'' already caught in try catch block
reserved.identifier = identifier ''{0}'' is a reserved identifier
ignored.assignment = assignment statement should have at least one variable assignment
cannot.assign.value.array.length = cannot assign a value to array length
missing.return.statement = missing return statement
abort.stmt.not.allowed.here = abort statement is not allowed here
return.cannot.used.in.transaction = return statement cannot be used in a transaction
transform.statement.invalid.input.output=input and output variables cannot be interchanged in transform statement
incompatible.types.in.multiple.assignment = incompatible types for ''{0}'': expected ''{1}'', found ''{2}''
cannot.resolve.struct = "could not resolve ''{0}':'{1}'' struct"
continue.stmt.not.allowed.here = continue statement is not allowed here
reply.stmt.not.allowed.here=reply statement not allowed here within worker
return.stmt.not.allowed.here=return statement not allowed here within worker
break.used.in.transaction=break statement cannot be used to exit from a transaction
continue.used.in.transaction=continue statement cannot be used to exit from a transaction
from.and.to.array.type.mismatch = arguments have different types:''{0}'' and ''{1}''
unsafe.cast.attempt = unsafe cast from ''{0}'' to ''{1}'', use multi-return cast expression
unsafe.conversion.attempt = unsafe conversion from ''{0}'' to ''{1}'', use multi-return conversion expression
invalid.action.invocation = invalid action invocation expression
incorrect.action.invocation = invalid action invocation. connector variable expected
invalid.var.assignment = invalid usage of 'var'
xml.attribute.map.update.not.allowed = xml attributes cannot be updated as a collection. update attributes one at a time
xml.qname.update.not.allowed = cannot assign values to an xml qualified name
undefined.namespace = undefined namespace ''{0}''
incorrect.function.arguments = incorrect arguments for function pointer - ''{0}''
server.connector.already.exist = server connector config with port - {0} already exist with different parameters
invalid.service.protocol = server connector does not exist for the module ''{0}''
no.new.variables.var.assignment = no new variables on left side
annotation.attribute.value.cannot.refer.non.constant = annotation attribute value should be either constant reference or a basic literal
invalid.namespace.prefix = invalid namespace prefix ''{0}''
mismatching.xml.start.end.tags = mismatching start and end tags found
incompatible.types.in.xml.template = incompatible types in xml template literal. expected ''xml'' or ''string'', found ''{0}''
invalid.namespace.declaration = cannot bind a prefix (''{0}'') to the empty namespace name
connector.input.types.are.not.equivalent = connector input types are not equivalent in connectors ''{0}'' and ''{1}''
connector.types.not.equivalent = connector types ''{0}'' and ''{1}'' are not equivalent
filter.connector.must.be.a.connector = filter connector ''{0}'' must be of connector type
unknown.field.in.json.struct = unknown field ''{0}'' in json with struct constraint ''{1}''
invalid.action.first.parameter = first parameter of the action should be of connector type ''{0}''
retry.stmt.not.allowed.here = retry statement not allowed here
invalid.retry.count = invalid retry count
arguments.count.mismatch = arguments count mismatch: expected {0}, found {1}
not.enough.format.arguments = not enough format arguments
invalid.format.specifier = unknown format conversion ''{0}''
invalid.map.insertion = invalid map insertion: expected value of type ''{0}'', found ''{1}''
invalid.value.load = value ''{0}'' cannot be assigned to type ''{1}''
invalid.task.config = Task scheduling configuration is invalid
task.already.running = The task is already running
task.not.running = The task in not running
illegal.format.conversion = illegal format conversion ''{0}''
incompatible.stamp.operation = incompatible stamp operation: ''{0}'' value cannot be stamped as ''{1}''
cannot.stamp.null = cannot stamp ''null'' value to type ''{0}''
cannot.convert.nil = cannot convert ''()'' to type ''{0}''
incompatible.convert.operation = ''{0}'' value cannot be converted to ''{1}''
incompatible.simple.type.convert.operation = ''{0}'' value ''{1}'' cannot be converted to ''{2}''
unsupported.clone.operation = ''clone()'' not allowed on ''{0}''
invalid.record.field.access = invalid field access: field ''{0}'' not found in record type ''{1}''
invalid.record.field.addition = invalid value for record field ''{0}'': expected value of type ''{1}'', found ''{2}''
invalid.object.field.addition = invalid value for object field ''{0}'': expected value of type ''{1}'', found ''{2}''
dynamically.nested.transactions.are.not.allowed = dynamically nested transactions are not allowed
cyclic.value.reference = ''{0}'' value has cyclic reference
tuple.index.out.of.range = tuple index out of range: index: {0}, size: {1}
illegal.array.insertion = array of length {0} cannot be expanded into array of length {1} without filler values
illegal.tuple.insertion = tuple of length {0} cannot be expanded into tuple of length {1} without filler values
unexpected.xml.type = lang.xml function ''{0}'' only accept xml type ''{1}''
java.null.reference = handle refers to Java null
illegal.array.size = cannot change the length of an array of fixed length ''{0}'' to ''{1}''
illegal.tuple.size = cannot change the length of a tuple of fixed length ''{0}'' to ''{1}''
illegal.rest.tuple.size = cannot change the length of a tuple with ''{0}'' mandatory member(s) to ''{1}''
string.index.out.of.range = string index out of range: index: {0}, size: {1}
substring.index.out.of.range = string index out of range. Length:''{0}'' requested: ''{1}'' to ''{2}''
codepoint.index.out.of.range = string codepoint index out of range: {0}
invalid.substring.range = invalid substring range. Length:''{0}'' requested: ''{1}'' to ''{2}''
xml.index.out.of.range = xml sequence index out of range. Length: ''{0}'' requested: ''{1}''
invalid.xml.attribute = invalid xml attribute access on xml {0}
attribute.not.found = attribute ''{0}'' not found
record.invalid.readonly.field.update = cannot update ''readonly'' field ''{0}'' in record of type ''{1}''
invalid.update.on.readonly.value = modification not allowed on readonly value
object.invalid.final.field.update = cannot update ''final'' field ''{0}'' in object of type ''{1}''
unsupported.comparison.operation = cannot compare ''{0}'' and ''{1}''
unordered.types.in.comparison = ''{0}'' is unordered with respect to ''{1}''
incompatible.type.assignment = ''{0}'' cannot be assigned to type ''{1}''
incompatible.java.object.type.assignment = ''{0}'' is not from a valid java runtime class. It should be a subclass of \
  one of the following: java.lang.Number, java.lang.Boolean or from the package ''io.ballerina.runtime.api.values''
int.range.overflow = int range overflow
invalid.value.for.object.field = invalid value for object field ''{0}'': expected value of type ''{1}'', found ''{2}''
key.not.found = cannot find key ''{0}''
key.not.found.in.value = key ''{0}'' not found in value ''{1}''
table.has.a.value.for.key = a value found for key ''{0}''
key.not.found.in.json.mapping = key ''{0}'' not found in JSON mapping
merge.json.error = cannot merge JSON values of types ''{0}'' and ''{1}''
field.removal.not.allowed = failed to remove field: ''{0}'' is a required field in ''{1}''
operation.not.supported = {0} not supported on type ''{1}''
invalid.fraction.digits = fraction digits cannot be less than '0'
#configurations
config.type.not.supported = configurable variable ''{0}'' with type ''{1}'' is not supported
config.invalid.byte.range = [{0}] value provided for byte variable ''{1}'' is out of range. Expected range is \
(0-255), found ''{2}''
config.value.not.provided = value not provided for required configurable variable ''{0}''
config.incompatible.type = [{0}] configurable variable ''{1}'' is expected to be of type ''{2}'', but found ''{3}''
config.union.value.ambiguous.target = [{0}] ambiguous target types found for configurable variable ''{1}'' with type \
  ''{2}''

#configurations.toml
config.toml.invalid.file = invalid toml file : {0}
config.toml.file.not.found=configuration file is not found in path ''{0}''
config.toml.invalid.additional.record.field = [{0}] undefined field ''{1}'' provided for closed record ''{2}''
config.toml.field.not.supported = [ {0} ] field type ''{1}'' in configurable variable ''{2}'' is not supported
config.toml.required.field.not.provided = [{0}] value not provided for non-defaultable required field ''{1}'' of \
record ''{2}'' in configurable variable ''{3}''
config.toml.table.key.not.provided = [{0}] value required for key ''{1}'' of type ''{2}'' in configurable variable \
  ''{3}''
config.toml.invalid.module.structure = [{0}] invalid toml structure found for module ''{1}''. Please provide the \
  module name as ''[{2}]''
config.toml.default.field.not.supported = [{0}] defaultable readonly record field ''{1}'' in configurable variable\
''{2}'' is not supported
config.toml.empty.file = an empty configuration file is found in path ''{0}''. Please provide values for \
configurable variables
config.toml.empty.content = [{0}] environment variable ''{1}'' contains an empty string. Please provide values for\
   configurable variables
config.toml.field.incompatible.type = [{0}] field ''{1}'' from configurable variable ''{2}'' is \
  expected to be of type ''{3}'', but found ''{4}''
config.toml.read.failed = failed to read file: ''{0}'' due to \n''{1}''
config.toml.parse.failed = failed to parse file: ''{0}'' due to \n''{1}''
config.toml.module.ambiguity =  [{0}] the module name ''{1}'' clashes with an imported organization name. Please \
  provide the module name as ''[{2}]''
config.toml.unused.value =  [{0}] unused configuration value ''{1}''

#configurations.cli
config.cli.type.not.supported = value for configurable variable ''{0}'' with type ''{1}'' is not supported as \
  a command line argument
config.cli.variable.ambiguity = configurable value for variable ''{0}'' clashes with variable ''{1}''. Please \
  provide the command line argument as ''[{2}]''
config.cli.args.ambiguity = configurable value for variable ''{0}'' clashes with multiple command line arguments {1}
config.cli.unused.args = [{0}] unused command line argument
large.number.of.exponents.in.decimal = too many exponents found in decimal value ''{0}''
unsupported.decimal.value = decimal operation resulting in unsupported decimal value ''{0}''
decimal.value.out.of.range = decimal range overflow
config.size.mismatch = [{0}] the size for configurable variable ''{1}'' is expected to be ''{2}'', \
  but found ''{3}''
invalid.utf8.byte.array.value = array contains invalid UTF-8 byte value
