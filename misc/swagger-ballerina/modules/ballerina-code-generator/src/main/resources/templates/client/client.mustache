import ballerina/io;
import ballerina/http;

//=====================================
//============Client Config============
//=====================================
public type {{name}}ClientConfig record {
    string serviceUrl;
};

//=======================================
//============Client Endpoint============
//=======================================
public type {{name}}ClientEp object {
    public http:Client client;
    public {{name}}ClientConfig config;

    public function init({{name}}ClientConfig clientConfig);
    public function getCallerActions() returns ({{name}}Client);
};

function {{name}}ClientEp::init({{name}}ClientConfig clientConfig) {
    endpoint http:Client httpEp {
        url: clientConfig.serviceUrl
    };

    self.client = httpEp;
    self.config = clientConfig;
}

function {{name}}ClientEp::getCallerActions() returns ({{name}}Client) {
    return new {{name}}Client(self);
}

//==============================
//============Client============
//==============================
public type {{name}}Client object {
    public {{name}}ClientEp clientEp;

    new (clientEp) {}
    {{#resources}}{{#isMultiMethod}}{{#supportedMethods}}
    public function {{lower .}}{{name}}({{#parameters}}{{type}} {{name}}{{#unless @last}}, {{/unless}}{{/parameters}}) returns http:Response | error;{{/supportedMethods}}{{/isMultiMethod}}{{^isMultiMethod}}
    public function {{name}}({{#parameters}}{{type}} {{name}}{{#unless @last}}, {{/unless}}{{/parameters}}) returns http:Response | error;{{/isMultiMethod}}{{/resources}}
};
{{#resources}}{{#isMultiMethod}}{{#supportedMethods}}
function {{../../name}}Client::{{lower .}}{{../name}}({{#parameters}}{{type}} {{../name}}{{#unless @last}}, {{/unless}}{{/parameters}}) returns http:Response | error {
    endpoint http:Client ep = self.clientEp.client;
    http:Request request = new;

    //Create the required request as needed{{#contentType}}
    request.setHeader("Content-Type", "{{contentType}}");{{/contentType}}
    string path = string `{{path}}`;
    return check ep->{{lower .}}(path, message = request);
}
{{/supportedMethods}}{{/isMultiMethod}}{{^isMultiMethod}}
function {{../name}}Client::{{name}}({{#parameters}}{{type}} {{name}}{{#unless @last}}, {{/unless}}{{/parameters}}) returns http:Response | error {
    endpoint http:Client ep = self.clientEp.client;
    http:Request request = new;

    //Create the required request as needed{{#contentType}}
    request.setHeader("Content-Type", "{{contentType}}");{{/contentType}}
    string path = string `{{path}}`;
    return check ep->{{lower method}}(path, message = request);
}{{/isMultiMethod}}
{{/resources}}
{{#if endpoints}}//======================================================
//============Invocation of Generated Client============
//======================================================
function main (string... args) { {{#endpoints}}
    endpoint {{../name}}ClientEp ep{{@index}} {
        serviceUrl: "{{url}}"
    };{{/endpoints}}

    {{#resources.0}}
    // Sample invocation of the generated client connector{{#isMultiMethod}}{{#supportedMethods.0}}
    var res = ep0->{{lower .}}{{name}}({{#parameters}}{{>arguments}}{{/parameters}});{{/supportedMethods.0}}{{/isMultiMethod}}{{^isMultiMethod}}
    var res = ep0->{{name}}({{#parameters}}{{>arguments}}{{/parameters}});{{/isMultiMethod}}
    match (res) {
        error err => io:println(err.message);
            http:Response resp => {
                var payload = resp.getTextPayload();
                match payload {
                    error err => io:println(err.message);
                    string message => io:println(message);
                }
            }
    }{{/resources.0}}
}{{/if}}
