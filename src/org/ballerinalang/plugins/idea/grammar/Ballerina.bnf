{

  classHeader='CopyrightHeader'
  parserClass="org.ballerinalang.plugins.idea.parser.BallerinaParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Ballerina"
  psiImplClassSuffix="Impl"
  psiPackage="org.ballerinalang.plugins.idea.psi"
  psiImplPackage="org.ballerinalang.plugins.idea.psi.impl"

  elementTypeHolderClass="org.ballerinalang.plugins.idea.psi.BallerinaTypes"
  elementTypeClass="org.ballerinalang.plugins.idea.psi.BallerinaElementType"
  tokenTypeClass="org.ballerinalang.plugins.idea.psi.BallerinaTokenType"

  tokens=[

      // ยง3.9 Ballerina keywords
      ACTION                = 'action';
      BREAK                 = 'break';
      CATCH                 = 'catch';
      CONNECTOR             = 'connector';
      CONST                 = 'const';
      ELSE                  = 'else';
      FORK                  = 'fork';
      FUNCTION              = 'function';
      IF                    = 'if';
      IMPORT                = 'import';
      ITERATE               = 'iterate';
      JOIN                  = 'join';
      NEW                   = 'new';
      PACKAGE               = 'package';
      REPLY                 = 'reply';
      RESOURCE              = 'resource';
      RETURN                = 'return';
      SERVICE               = 'service';
      THROW                 = 'throw';
      THROWS                = 'throws';
      TRY                   = 'try';
      TYPE                  = 'type';
      TYPECONVERTOR         = 'typeconvertor';
      WHILE                 = 'while';
      WORKER                = 'worker';
      BACKTICK              = '`';
      VERSION               = 'version';
      PUBLIC                = 'public';
      ANY                   = 'any';
      ALL                   = 'all';
      AS                    = 'as';
      TIMEOUT               = 'timeout';
      SENDARROW             = '->';
      RECEIVEARROW          = '<-';

      // ยง3.11 Separators
      LPAREN                = '(';
      RPAREN                = ')';
      LBRACE                = '{';
      RBRACE                = '}';
      LBRACK                = '[';
      RBRACK                = ']';
      SEMI                  = ';';
      COMMA                 = ',';
      DOT                   = '.';

      // ยง3.12 Operators
      ASSIGN                = '=';
      GT                    = '>';
      LT                    = '<';
      BANG                  = '!';
      TILDE                 = '~';
      QUESTION              = '?';
      COLON                 = ':';
      EQUAL                 = '==';
      LE                    = '<=';
      GE                    = '>=';
      NOTEQUAL              = '!=';
      AND                   = '&&';
      OR                    = '||';
      ADD                   = '+';
      SUB                   = '-';
      MUL                   = '*';
      DIV                   = '/';
      BITAND                = '&';
      BITOR                 = '|';
      CARET                 = '^';
      MOD                   = '%';
      DOLLAR_SIGN           = '$';

      AT                    = '@';

      NullLiteral           = "null"

      IntegerLiteral        = "regexp:0|[1-9][0-9]*"

      FloatingPointLiteral  = "regexp:(([0-9]+\.[0-9]*)|(\.[0-9]+)|([0-9]+))([eE][+-]?[0-9]+)?[fF]"

      BooleanLiteral        = "regexp:(true|false)"

      QuotedStringLiteral   = 'regexp:\"([^\\\"\r\n]|\\[^\r\n])*(\"|\\)?'

      ValidBackTickString   = 'regexp:`[^`]*`'

      Identifier            = "regexp:[a-zA-Z$_][a-zA-Z0-9$_]*"

      Letter                = "regexp:[a-zA-Z$_]"

      LetterOrDigit         = "regexp:[a-zA-Z0-9$_]"

      WHITE_SPACE           = 'regexp:[ \t\r\n\u000C]+'

      LINE_COMMENT          = 'regexp://[^\r\n]*'

//      FloatLiteral  = "regexp:(([0-9]+\.[0-9]*)|(\.[0-9]+)|([0-9]+))([eE][+-]?[0-9]+)?[fF]"
//      DoubleLiteral =  "regexp:((([0-9]+\.[0-9]*)|(\.[0-9]+)|([0-9]+))([eE][+-]?[0-9]+)?"
//
//      FLit1    = ([0-9]+\.[0-9]*)
//      FLit2    = (\.[0-9]+)
//      FLit3    = ([0-9]+)
//      Exponent = ([eE][+-]?[0-9]+)
  ]
}

compilationUnit
    ::=   packageDeclaration?
        importDeclaration*
    (   serviceDefinition
    |   functionDefinition
    |   connectorDefinition
    |   structDefinition
    |   typeConvertorDefinition
    |   constantDefinition
    )+

packageDeclaration
    ::=   'package' packageName ';'

importDeclaration
    ::=   'import' packageName ('as' Identifier)? ';'

serviceDefinition
    ::=   annotation* 'service' Identifier '{' serviceBody '}'

serviceBody
    ::=   serviceBodyDeclaration

serviceBodyDeclaration
    ::=  connectorDeclaration* variableDeclaration* resourceDefinition+

resourceDefinition
    ::=   annotation* 'resource' Identifier '(' parameterList ')' '{' functionBody '}'

functionDefinition
    ::=   annotation* 'public'? 'function' Identifier '(' parameterList? ')' returnParameters? ('throws' Identifier)? '{' functionBody '}'

functionBody
    ::=  connectorDeclaration* variableDeclaration* workerDeclaration* statement+

connectorDefinition
    ::=   annotation* 'connector' Identifier '(' parameterList ')' '{' connectorBody '}'

connectorBody
    ::=    connectorDeclaration* variableDeclaration* actionDefinition+

actionDefinition
    ::=   annotation* 'action' Identifier '(' parameterList ')' returnParameters?  ('throws' Identifier)? '{' functionBody '}'

connectorDeclaration
    ::=   qualifiedReference Identifier '=' 'new' qualifiedReference '(' expressionList? ')'';'

structDefinition
    ::=   'public'? 'type' Identifier structDefinitionBody

structDefinitionBody
    ::=   '{' (typeName Identifier ';')+ '}'

typeConvertorDefinition
    ::=   'typeconvertor' Identifier '(' typeConverterTypes Identifier ')' '('typeConverterTypes')' '{' typeConvertorBody '}'

typeConvertorBody
    ::=    variableDeclaration* statement+

constantDefinition
    ::=   'const' typeName Identifier '=' literalValue ';'

variableDeclaration
    ::=   typeName Identifier ';'

// typeName below is only 'message' type
workerDeclaration
    ::=   'worker' Identifier '(' typeName Identifier ')'  '{' variableDeclaration* statement+ '}'

returnParameters
    ::= '(' (namedParameterList | returnTypeList) ')'

namedParameterList
    ::=   namedParameter (',' namedParameter)*

namedParameter
    ::=   typeName Identifier

returnTypeList
    ::=   typeName (',' typeName)*

qualifiedTypeName
    ::=   packageName ':' unqualifiedTypeName

typeConverterTypes
    ::=   withFullSchemaType
    |   withSchemaIdType
    |   withScheamURLType
    |   simpleType

unqualifiedTypeName
    ::=   simpleTypeArray
    |   simpleTypeIterate
    |   withFullSchemaType
    |   withFullSchemaTypeArray
    |   withFullSchemaTypeIterate
    |   withScheamURLType
    |   withSchemaURLTypeArray
    |   withSchemaURLTypeIterate
    |   withSchemaIdType
    |   withScheamIdTypeArray
    |   withScheamIdTypeIterate
    |   simpleType

simpleType
    ::=   Identifier

simpleTypeArray
    ::=   Identifier '[' ']'

simpleTypeIterate
    ::= Identifier '~'

withFullSchemaType
    ::= Identifier '<' '{' QuotedStringLiteral '}' Identifier '>'

withFullSchemaTypeArray
    ::= Identifier '<' '{' QuotedStringLiteral '}' Identifier '>' '[' ']'

withFullSchemaTypeIterate
    ::= Identifier '<' '{' QuotedStringLiteral '}' Identifier '>' '~'

withScheamURLType
    ::= Identifier '<' '{' QuotedStringLiteral '}' '>'

withSchemaURLTypeArray
    ::= Identifier '<' '{' QuotedStringLiteral '}' '>' '[' ']'

withSchemaURLTypeIterate
    ::= Identifier '<' '{' QuotedStringLiteral '}' '>' '~'

withSchemaIdType
    ::= Identifier '<' Identifier '>'

withScheamIdTypeArray
    ::= Identifier '<' Identifier '>' '[' ']'

withScheamIdTypeIterate
    ::= Identifier '<' Identifier '>' '~'

typeName
    ::=   unqualifiedTypeName
    |   qualifiedTypeName

qualifiedReference
    ::=   packageName ':' Identifier

parameterList
    ::=   parameter  (',' parameter )*

parameter
    ::=   annotation* typeName Identifier

packageName
    ::=   Identifier ('.' Identifier)*

literalValue
    ::=   IntegerLiteral
    |   FloatingPointLiteral
    |   QuotedStringLiteral
    |   BooleanLiteral
    |   NullLiteral

 //============================================================================================================
 // ANNOTATIONS

 annotation
     ::=   '@' annotationName ( '(' ( elementValuePairs | elementValue )? ')' )?

 annotationName ::= Identifier

 elementValuePairs
     ::=   elementValuePair (',' elementValuePair)*

 elementValuePair
     ::=    Identifier '=' elementValue

 elementValue
     ::=   expression
     |   annotation
     |   elementValueArrayInitializer

 elementValueArrayInitializer
     ::=   '{' (elementValue (',' elementValue)*)? (',')? '}'

 //============================================================================================================
// STATEMENTS / BLOCKS

statement
    ::=   functionInvocationStatement
    |   ifElseStatement
    |   iterateStatement
    |   whileStatement
    |   breakStatement
    |   forkJoinStatement
    |   tryCatchStatement
    |   throwStatement
    |   returnStatement
    |   replyStatement
    |   workerInteractionStatement
    |   commentStatement
    |   actionInvocationStatement
    |   assignmentStatement

assignmentStatement
    ::=   variableReferenceList '=' expression ';'

variableReferenceList
    ::=   variableReference (',' variableReference)*

ifElseStatement
    ::=   'if' '(' expression ')' '{' ifElseIfClauseBody '}' (elseIfClause '}')* (elseClause '}')?

elseIfClause
    ::=   'else' 'if' '(' expression ')' '{' ifElseIfClauseBody

elseClause
    ::=   'else' '{' ifElseIfClauseBody

ifElseIfClauseBody::=  statement*

iterateStatement
    ::=   'iterate' '(' typeName Identifier ':' expression ')' '{' statement+ '}'

whileStatement
    ::=   'while' '(' expression ')' '{' whileStatementBody '}'

whileStatementBody::=statement+

breakStatement
    ::=   'break' ';'

// typeName is only message
forkJoinStatement
    ::=   'fork' '(' typeName Identifier ')' '{' workerDeclaration+ '}' joinClause? timeoutClause?

// below typeName is only 'message[]'
joinClause
    ::=   'join' '(' joinConditions ')' '(' typeName Identifier ')'  '{' statement+ '}'

joinConditions
    ::=   'any' IntegerLiteral (Identifier (',' Identifier)*)?
    |   'all' (Identifier (',' Identifier)*)?

// below typeName is only 'message[]'
timeoutClause
    ::=   'timeout' '(' expression ')' '(' typeName Identifier ')'  '{' statement+ '}'

//todo: need to rearrange
tryCatchStatement
    ::=   'try' '{' tryCatchStatementBody '}' catchClause '}'

// below tyeName is only 'exception'
catchClause
    ::=   'catch' '(' typeName Identifier ')' '{' tryCatchStatementBody

tryCatchStatementBody
    ::=   statement+

throwStatement
    ::=   'throw' expression ';'

returnStatement
    ::=   'return' expressionList? ';'

// below Identifier is only a type of 'message'
replyStatement
    ::=   'reply' expression ';'

workerInteractionStatement
    ::=   triggerWorker
    |   workerReply

// below left Identifier is of type 'message' and the right Identifier is of type 'worker'
triggerWorker
    ::=   Identifier '->' Identifier ';'

// below left Identifier is of type 'worker' and the right Identifier is of type 'message'
workerReply
    ::=   Identifier '<-' Identifier ';'

commentStatement
    ::=   LINE_COMMENT

actionInvocationStatement
    ::=   actionInvocation argumentList ';'

//todo: fix left recursion here
variableReference
    ::=   variableReferenceTypes ('.' variableReferenceTypes)+  // structFieldIdentifier// struct field reference
    |     variableReferenceTypes

private variableReferenceTypes
    ::=   Identifier '['expression']'                           // mapArrayVariableIdentifier// array and map reference
    |     Identifier                                            // simpleVariableIdentifier// simple identifier

argumentList
    ::=   '(' expressionList? ')'

expressionList
    ::=   expression (',' expression)*

functionInvocationStatement
    ::=   functionName argumentList ';'

functionName
    ::=   (packageName ':')? Identifier

actionInvocation
    ::=   packageName ':' Identifier '.' Identifier

backtickString
   ::=     ValidBackTickString

expression::=
       '(' typeName ')' basicExpression
    |   ('+'|'-'|'!') basicExpression
    |   '(' basicExpression ')'
    |   basicExpression (('^' | '/' | '*' | '%' | '&&' | '+' | '-' | '||' | '>' | '>='| '<' | '<=' | '==' | '!=') basicExpression ) *

private basicExpression::=
        backtickString                                                      // templateExpression
    |   functionName argumentList                                           // functionInvocationExpression
    |   actionInvocation argumentList                                       // actionInvocationExpression
    |   '[' expressionList ']'                                              // arrayInitializerExpression
    |   '{' mapInitKeyValueList '}'                                         // mapInitializerExpression
    |   'new' (packageName ':' )? Identifier ('(' expressionList? ')')?     // structInitializeExpression
    |    literalValue                                                        // literalExpression
    |   variableReference
    |   '(' typeName ')' basicExpression
    |   ('+'|'-'|'!') basicExpression
    |   '(' basicExpression ')'

mapInitKeyValueList
    ::=   mapInitKeyValue (',' mapInitKeyValue)*

mapInitKeyValue
    ::=   QuotedStringLiteral ':' expression

NullLiteral
    ::=   'null'
